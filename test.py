# Generated by Haxe 4.1.2
# coding: utf-8
import sys

import inspect as python_lib_Inspect
import os as python_lib_Os
import sys as python_lib_Sys
import subprocess as python_lib_Subprocess
from subprocess import Popen as python_lib_subprocess_Popen
from io import BufferedReader as python_lib_io_BufferedReader
from io import TextIOWrapper as python_lib_io_TextIOWrapper
from io import BufferedWriter as python_lib_io_BufferedWriter
import math as python_lib_Math
import math as Math
import functools as python_lib_Functools
import timeit as python_lib_Timeit
import traceback as python_lib_Traceback
from io import StringIO as python_lib_io_StringIO


class _hx_AnonObject:
    _hx_disable_getattr = False
    def __init__(self, fields):
        self.__dict__ = fields
    def __repr__(self):
        return repr(self.__dict__)
    def __contains__(self, item):
        return item in self.__dict__
    def __getitem__(self, item):
        return self.__dict__[item]
    def __getattr__(self, name):
        if (self._hx_disable_getattr):
            raise AttributeError('field does not exist')
        else:
            return None
    def _hx_hasattr(self,field):
        self._hx_disable_getattr = True
        try:
            getattr(self, field)
            self._hx_disable_getattr = False
            return True
        except AttributeError:
            self._hx_disable_getattr = False
            return False



class Enum:
    _hx_class_name = "Enum"
    _hx_is_interface = "False"
    __slots__ = ("tag", "index", "params")
    _hx_fields = ["tag", "index", "params"]
    _hx_methods = ["__str__"]

    def __init__(self,tag,index,params):
        self.tag = tag
        self.index = index
        self.params = params

    def __str__(self):
        if (self.params is None):
            return self.tag
        else:
            return self.tag + '(' + (', '.join(str(v) for v in self.params)) + ')'

Enum._hx_class = Enum

class Attribute(Enum):
    __slots__ = ()
    _hx_class_name = "Attribute"
    _hx_constructs = ["Off", "Bold", "Underline", "Blink", "ReverseVideo", "Concealed", "BoldOff", "UnderlineOff", "BlinkOff", "NormalVideo", "ConcealedOff", "Black", "Red", "Green", "Yellow", "Blue", "Magenta", "Cyan", "White", "DefaultForeground", "BlackBack", "RedBack", "GreenBack", "YellowBack", "BlueBack", "MagentaBack", "CyanBack", "WhiteBack", "DefaultBackground"]
Attribute.Off = Attribute("Off", 0, ())
Attribute.Bold = Attribute("Bold", 1, ())
Attribute.Underline = Attribute("Underline", 2, ())
Attribute.Blink = Attribute("Blink", 3, ())
Attribute.ReverseVideo = Attribute("ReverseVideo", 4, ())
Attribute.Concealed = Attribute("Concealed", 5, ())
Attribute.BoldOff = Attribute("BoldOff", 6, ())
Attribute.UnderlineOff = Attribute("UnderlineOff", 7, ())
Attribute.BlinkOff = Attribute("BlinkOff", 8, ())
Attribute.NormalVideo = Attribute("NormalVideo", 9, ())
Attribute.ConcealedOff = Attribute("ConcealedOff", 10, ())
Attribute.Black = Attribute("Black", 11, ())
Attribute.Red = Attribute("Red", 12, ())
Attribute.Green = Attribute("Green", 13, ())
Attribute.Yellow = Attribute("Yellow", 14, ())
Attribute.Blue = Attribute("Blue", 15, ())
Attribute.Magenta = Attribute("Magenta", 16, ())
Attribute.Cyan = Attribute("Cyan", 17, ())
Attribute.White = Attribute("White", 18, ())
Attribute.DefaultForeground = Attribute("DefaultForeground", 19, ())
Attribute.BlackBack = Attribute("BlackBack", 20, ())
Attribute.RedBack = Attribute("RedBack", 21, ())
Attribute.GreenBack = Attribute("GreenBack", 22, ())
Attribute.YellowBack = Attribute("YellowBack", 23, ())
Attribute.BlueBack = Attribute("BlueBack", 24, ())
Attribute.MagentaBack = Attribute("MagentaBack", 25, ())
Attribute.CyanBack = Attribute("CyanBack", 26, ())
Attribute.WhiteBack = Attribute("WhiteBack", 27, ())
Attribute.DefaultBackground = Attribute("DefaultBackground", 28, ())
Attribute._hx_class = Attribute


class haxe_IMap:
    _hx_class_name = "haxe.IMap"
    _hx_is_interface = "True"
    __slots__ = ()
haxe_IMap._hx_class = haxe_IMap


class haxe_ds_StringMap:
    _hx_class_name = "haxe.ds.StringMap"
    _hx_is_interface = "False"
    __slots__ = ("h",)
    _hx_fields = ["h"]
    _hx_interfaces = [haxe_IMap]

    def __init__(self):
        self.h = dict()

haxe_ds_StringMap._hx_class = haxe_ds_StringMap


class python_HaxeIterator:
    _hx_class_name = "python.HaxeIterator"
    _hx_is_interface = "False"
    __slots__ = ("it", "x", "has", "checked")
    _hx_fields = ["it", "x", "has", "checked"]
    _hx_methods = ["next", "hasNext"]

    def __init__(self,it):
        self.checked = False
        self.has = False
        self.x = None
        self.it = it

    def next(self):
        if (not self.checked):
            self.hasNext()
        self.checked = False
        return self.x

    def hasNext(self):
        if (not self.checked):
            try:
                self.x = self.it.__next__()
                self.has = True
            except BaseException as _g:
                None
                if Std.isOfType(haxe_Exception.caught(_g).unwrap(),StopIteration):
                    self.has = False
                    self.x = None
                else:
                    raise _g
            self.checked = True
        return self.has

python_HaxeIterator._hx_class = python_HaxeIterator


class Sys:
    _hx_class_name = "Sys"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["environ", "exit", "getEnv", "systemName"]

    @staticmethod
    def exit(code):
        python_lib_Sys.exit(code)

    @staticmethod
    def getEnv(s):
        return Sys.environ.h.get(s,None)

    @staticmethod
    def systemName():
        _g = python_lib_Sys.platform
        x = _g
        if x.startswith("linux"):
            return "Linux"
        else:
            _g1 = _g
            _hx_local_0 = len(_g1)
            if (_hx_local_0 == 5):
                if (_g1 == "win32"):
                    return "Windows"
                else:
                    raise haxe_Exception.thrown("not supported platform")
            elif (_hx_local_0 == 6):
                if (_g1 == "cygwin"):
                    return "Windows"
                elif (_g1 == "darwin"):
                    return "Mac"
                else:
                    raise haxe_Exception.thrown("not supported platform")
            else:
                raise haxe_Exception.thrown("not supported platform")
Sys._hx_class = Sys


class HxString:
    _hx_class_name = "HxString"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["split", "charCodeAt", "charAt", "lastIndexOf", "toUpperCase", "toLowerCase", "indexOf", "indexOfImpl", "toString", "substring", "substr"]

    @staticmethod
    def split(s,d):
        if (d == ""):
            return list(s)
        else:
            return s.split(d)

    @staticmethod
    def charCodeAt(s,index):
        if ((((s is None) or ((len(s) == 0))) or ((index < 0))) or ((index >= len(s)))):
            return None
        else:
            return ord(s[index])

    @staticmethod
    def charAt(s,index):
        if ((index < 0) or ((index >= len(s)))):
            return ""
        else:
            return s[index]

    @staticmethod
    def lastIndexOf(s,_hx_str,startIndex = None):
        if (startIndex is None):
            return s.rfind(_hx_str, 0, len(s))
        elif (_hx_str == ""):
            length = len(s)
            if (startIndex < 0):
                startIndex = (length + startIndex)
                if (startIndex < 0):
                    startIndex = 0
            if (startIndex > length):
                return length
            else:
                return startIndex
        else:
            i = s.rfind(_hx_str, 0, (startIndex + 1))
            startLeft = (max(0,((startIndex + 1) - len(_hx_str))) if ((i == -1)) else (i + 1))
            check = s.find(_hx_str, startLeft, len(s))
            if ((check > i) and ((check <= startIndex))):
                return check
            else:
                return i

    @staticmethod
    def toUpperCase(s):
        return s.upper()

    @staticmethod
    def toLowerCase(s):
        return s.lower()

    @staticmethod
    def indexOf(s,_hx_str,startIndex = None):
        if (startIndex is None):
            return s.find(_hx_str)
        else:
            return HxString.indexOfImpl(s,_hx_str,startIndex)

    @staticmethod
    def indexOfImpl(s,_hx_str,startIndex):
        if (_hx_str == ""):
            length = len(s)
            if (startIndex < 0):
                startIndex = (length + startIndex)
                if (startIndex < 0):
                    startIndex = 0
            if (startIndex > length):
                return length
            else:
                return startIndex
        return s.find(_hx_str, startIndex)

    @staticmethod
    def toString(s):
        return s

    @staticmethod
    def substring(s,startIndex,endIndex = None):
        if (startIndex < 0):
            startIndex = 0
        if (endIndex is None):
            return s[startIndex:]
        else:
            if (endIndex < 0):
                endIndex = 0
            if (endIndex < startIndex):
                return s[endIndex:startIndex]
            else:
                return s[startIndex:endIndex]

    @staticmethod
    def substr(s,startIndex,_hx_len = None):
        if (_hx_len is None):
            return s[startIndex:]
        else:
            if (_hx_len == 0):
                return ""
            if (startIndex < 0):
                startIndex = (len(s) + startIndex)
                if (startIndex < 0):
                    startIndex = 0
            return s[startIndex:(startIndex + _hx_len)]
HxString._hx_class = HxString


class sys_io_Process:
    _hx_class_name = "sys.io.Process"
    _hx_is_interface = "False"
    __slots__ = ("stdout", "stderr", "stdin", "p")
    _hx_fields = ["stdout", "stderr", "stdin", "p"]
    _hx_methods = ["exitCode", "close"]

    def __init__(self,cmd,args = None,detached = None):
        self.stdin = None
        self.stderr = None
        self.stdout = None
        if detached:
            raise haxe_Exception.thrown("Detached process is not supported on this platform")
        args1 = (cmd if ((args is None)) else ([cmd] + args))
        o = _hx_AnonObject({'shell': (args is None), 'stdin': python_lib_Subprocess.PIPE, 'stdout': python_lib_Subprocess.PIPE, 'stderr': python_lib_Subprocess.PIPE})
        Reflect.setField(o,"bufsize",(Reflect.field(o,"bufsize") if (python_Boot.hasField(o,"bufsize")) else 0))
        Reflect.setField(o,"executable",(Reflect.field(o,"executable") if (python_Boot.hasField(o,"executable")) else None))
        Reflect.setField(o,"stdin",(Reflect.field(o,"stdin") if (python_Boot.hasField(o,"stdin")) else None))
        Reflect.setField(o,"stdout",(Reflect.field(o,"stdout") if (python_Boot.hasField(o,"stdout")) else None))
        Reflect.setField(o,"stderr",(Reflect.field(o,"stderr") if (python_Boot.hasField(o,"stderr")) else None))
        Reflect.setField(o,"preexec_fn",(Reflect.field(o,"preexec_fn") if (python_Boot.hasField(o,"preexec_fn")) else None))
        Reflect.setField(o,"close_fds",(Reflect.field(o,"close_fds") if (python_Boot.hasField(o,"close_fds")) else None))
        Reflect.setField(o,"shell",(Reflect.field(o,"shell") if (python_Boot.hasField(o,"shell")) else None))
        Reflect.setField(o,"cwd",(Reflect.field(o,"cwd") if (python_Boot.hasField(o,"cwd")) else None))
        Reflect.setField(o,"env",(Reflect.field(o,"env") if (python_Boot.hasField(o,"env")) else None))
        Reflect.setField(o,"universal_newlines",(Reflect.field(o,"universal_newlines") if (python_Boot.hasField(o,"universal_newlines")) else None))
        Reflect.setField(o,"startupinfo",(Reflect.field(o,"startupinfo") if (python_Boot.hasField(o,"startupinfo")) else None))
        Reflect.setField(o,"creationflags",(Reflect.field(o,"creationflags") if (python_Boot.hasField(o,"creationflags")) else 0))
        self.p = (python_lib_subprocess_Popen(args1,Reflect.field(o,"bufsize"),Reflect.field(o,"executable"),Reflect.field(o,"stdin"),Reflect.field(o,"stdout"),Reflect.field(o,"stderr"),Reflect.field(o,"preexec_fn"),Reflect.field(o,"close_fds"),Reflect.field(o,"shell"),Reflect.field(o,"cwd"),Reflect.field(o,"env"),Reflect.field(o,"universal_newlines"),Reflect.field(o,"startupinfo"),Reflect.field(o,"creationflags")) if ((Sys.systemName() == "Windows")) else python_lib_subprocess_Popen(args1,Reflect.field(o,"bufsize"),Reflect.field(o,"executable"),Reflect.field(o,"stdin"),Reflect.field(o,"stdout"),Reflect.field(o,"stderr"),Reflect.field(o,"preexec_fn"),Reflect.field(o,"close_fds"),Reflect.field(o,"shell"),Reflect.field(o,"cwd"),Reflect.field(o,"env"),Reflect.field(o,"universal_newlines"),Reflect.field(o,"startupinfo")))
        self.stdout = python_io_IoTools.createFileInputFromText(python_lib_io_TextIOWrapper(python_lib_io_BufferedReader(self.p.stdout)))
        self.stderr = python_io_IoTools.createFileInputFromText(python_lib_io_TextIOWrapper(python_lib_io_BufferedReader(self.p.stderr)))
        self.stdin = python_io_IoTools.createFileOutputFromText(python_lib_io_TextIOWrapper(python_lib_io_BufferedWriter(self.p.stdin)))

    def exitCode(self,block = None):
        if (block is None):
            block = True
        if (block == False):
            return self.p.poll()
        return self.p.wait()

    def close(self):
        ver = python_lib_Sys.version_info
        if ((ver[0] > 3) or (((ver[0] == 3) and ((ver[1] >= 3))))):
            try:
                self.p.terminate()
            except BaseException as _g:
                None
                if (not Std.isOfType(haxe_Exception.caught(_g).unwrap(),ProcessLookupError)):
                    raise _g
        else:
            try:
                self.p.terminate()
            except BaseException as _g:
                None
                if (not Std.isOfType(haxe_Exception.caught(_g).unwrap(),OSError)):
                    raise _g

sys_io_Process._hx_class = sys_io_Process


class python_Boot:
    _hx_class_name = "python.Boot"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["keywords", "toString1", "fields", "simpleField", "hasField", "field", "getInstanceFields", "getSuperClass", "getClassFields", "prefixLength", "unhandleKeywords"]

    @staticmethod
    def toString1(o,s):
        if (o is None):
            return "null"
        if isinstance(o,str):
            return o
        if (s is None):
            s = ""
        if (len(s) >= 5):
            return "<...>"
        if isinstance(o,bool):
            if o:
                return "true"
            else:
                return "false"
        if (isinstance(o,int) and (not isinstance(o,bool))):
            return str(o)
        if isinstance(o,float):
            try:
                if (o == int(o)):
                    return str(Math.floor((o + 0.5)))
                else:
                    return str(o)
            except BaseException as _g:
                None
                return str(o)
        if isinstance(o,list):
            o1 = o
            l = len(o1)
            st = "["
            s = (("null" if s is None else s) + "\t")
            _g = 0
            _g1 = l
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                prefix = ""
                if (i > 0):
                    prefix = ","
                st = (("null" if st is None else st) + HxOverrides.stringOrNull(((("null" if prefix is None else prefix) + HxOverrides.stringOrNull(python_Boot.toString1((o1[i] if i >= 0 and i < len(o1) else None),s))))))
            st = (("null" if st is None else st) + "]")
            return st
        try:
            if hasattr(o,"toString"):
                return o.toString()
        except BaseException as _g:
            None
        if hasattr(o,"__class__"):
            if isinstance(o,_hx_AnonObject):
                toStr = None
                try:
                    fields = python_Boot.fields(o)
                    _g = []
                    _g1 = 0
                    while (_g1 < len(fields)):
                        f = (fields[_g1] if _g1 >= 0 and _g1 < len(fields) else None)
                        _g1 = (_g1 + 1)
                        x = ((("" + ("null" if f is None else f)) + " : ") + HxOverrides.stringOrNull(python_Boot.toString1(python_Boot.simpleField(o,f),(("null" if s is None else s) + "\t"))))
                        _g.append(x)
                    fieldsStr = _g
                    toStr = (("{ " + HxOverrides.stringOrNull(", ".join([x1 for x1 in fieldsStr]))) + " }")
                except BaseException as _g:
                    None
                    return "{ ... }"
                if (toStr is None):
                    return "{ ... }"
                else:
                    return toStr
            if isinstance(o,Enum):
                o1 = o
                l = len(o1.params)
                hasParams = (l > 0)
                if hasParams:
                    paramsStr = ""
                    _g = 0
                    _g1 = l
                    while (_g < _g1):
                        i = _g
                        _g = (_g + 1)
                        prefix = ""
                        if (i > 0):
                            prefix = ","
                        paramsStr = (("null" if paramsStr is None else paramsStr) + HxOverrides.stringOrNull(((("null" if prefix is None else prefix) + HxOverrides.stringOrNull(python_Boot.toString1(o1.params[i],s))))))
                    return (((HxOverrides.stringOrNull(o1.tag) + "(") + ("null" if paramsStr is None else paramsStr)) + ")")
                else:
                    return o1.tag
            if hasattr(o,"_hx_class_name"):
                if (o.__class__.__name__ != "type"):
                    fields = python_Boot.getInstanceFields(o)
                    _g = []
                    _g1 = 0
                    while (_g1 < len(fields)):
                        f = (fields[_g1] if _g1 >= 0 and _g1 < len(fields) else None)
                        _g1 = (_g1 + 1)
                        x = ((("" + ("null" if f is None else f)) + " : ") + HxOverrides.stringOrNull(python_Boot.toString1(python_Boot.simpleField(o,f),(("null" if s is None else s) + "\t"))))
                        _g.append(x)
                    fieldsStr = _g
                    toStr = (((HxOverrides.stringOrNull(o._hx_class_name) + "( ") + HxOverrides.stringOrNull(", ".join([x1 for x1 in fieldsStr]))) + " )")
                    return toStr
                else:
                    fields = python_Boot.getClassFields(o)
                    _g = []
                    _g1 = 0
                    while (_g1 < len(fields)):
                        f = (fields[_g1] if _g1 >= 0 and _g1 < len(fields) else None)
                        _g1 = (_g1 + 1)
                        x = ((("" + ("null" if f is None else f)) + " : ") + HxOverrides.stringOrNull(python_Boot.toString1(python_Boot.simpleField(o,f),(("null" if s is None else s) + "\t"))))
                        _g.append(x)
                    fieldsStr = _g
                    toStr = (((("#" + HxOverrides.stringOrNull(o._hx_class_name)) + "( ") + HxOverrides.stringOrNull(", ".join([x1 for x1 in fieldsStr]))) + " )")
                    return toStr
            if (o == str):
                return "#String"
            if (o == list):
                return "#Array"
            if callable(o):
                return "function"
            try:
                if hasattr(o,"__repr__"):
                    return o.__repr__()
            except BaseException as _g:
                None
            if hasattr(o,"__str__"):
                return o.__str__([])
            if hasattr(o,"__name__"):
                return o.__name__
            return "???"
        else:
            return str(o)

    @staticmethod
    def fields(o):
        a = []
        if (o is not None):
            if hasattr(o,"_hx_fields"):
                fields = o._hx_fields
                if (fields is not None):
                    return list(fields)
            if isinstance(o,_hx_AnonObject):
                d = o.__dict__
                keys = d.keys()
                handler = python_Boot.unhandleKeywords
                for k in keys:
                    if (k != '_hx_disable_getattr'):
                        a.append(handler(k))
            elif hasattr(o,"__dict__"):
                d = o.__dict__
                keys1 = d.keys()
                for k in keys1:
                    a.append(k)
        return a

    @staticmethod
    def simpleField(o,field):
        if (field is None):
            return None
        field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
        if hasattr(o,field1):
            return getattr(o,field1)
        else:
            return None

    @staticmethod
    def hasField(o,field):
        if isinstance(o,_hx_AnonObject):
            return o._hx_hasattr(field)
        return hasattr(o,(("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field)))

    @staticmethod
    def field(o,field):
        if (field is None):
            return None
        if isinstance(o,str):
            field1 = field
            _hx_local_0 = len(field1)
            if (_hx_local_0 == 10):
                if (field1 == "charCodeAt"):
                    return python_internal_MethodClosure(o,HxString.charCodeAt)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    if hasattr(o,field1):
                        return getattr(o,field1)
                    else:
                        return None
            elif (_hx_local_0 == 11):
                if (field1 == "lastIndexOf"):
                    return python_internal_MethodClosure(o,HxString.lastIndexOf)
                elif (field1 == "toLowerCase"):
                    return python_internal_MethodClosure(o,HxString.toLowerCase)
                elif (field1 == "toUpperCase"):
                    return python_internal_MethodClosure(o,HxString.toUpperCase)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    if hasattr(o,field1):
                        return getattr(o,field1)
                    else:
                        return None
            elif (_hx_local_0 == 9):
                if (field1 == "substring"):
                    return python_internal_MethodClosure(o,HxString.substring)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    if hasattr(o,field1):
                        return getattr(o,field1)
                    else:
                        return None
            elif (_hx_local_0 == 5):
                if (field1 == "split"):
                    return python_internal_MethodClosure(o,HxString.split)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    if hasattr(o,field1):
                        return getattr(o,field1)
                    else:
                        return None
            elif (_hx_local_0 == 7):
                if (field1 == "indexOf"):
                    return python_internal_MethodClosure(o,HxString.indexOf)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    if hasattr(o,field1):
                        return getattr(o,field1)
                    else:
                        return None
            elif (_hx_local_0 == 8):
                if (field1 == "toString"):
                    return python_internal_MethodClosure(o,HxString.toString)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    if hasattr(o,field1):
                        return getattr(o,field1)
                    else:
                        return None
            elif (_hx_local_0 == 6):
                if (field1 == "charAt"):
                    return python_internal_MethodClosure(o,HxString.charAt)
                elif (field1 == "length"):
                    return len(o)
                elif (field1 == "substr"):
                    return python_internal_MethodClosure(o,HxString.substr)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    if hasattr(o,field1):
                        return getattr(o,field1)
                    else:
                        return None
            else:
                field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                if hasattr(o,field1):
                    return getattr(o,field1)
                else:
                    return None
        elif isinstance(o,list):
            field1 = field
            _hx_local_1 = len(field1)
            if (_hx_local_1 == 11):
                if (field1 == "lastIndexOf"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.lastIndexOf)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    if hasattr(o,field1):
                        return getattr(o,field1)
                    else:
                        return None
            elif (_hx_local_1 == 4):
                if (field1 == "copy"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.copy)
                elif (field1 == "join"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.join)
                elif (field1 == "push"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.push)
                elif (field1 == "sort"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.sort)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    if hasattr(o,field1):
                        return getattr(o,field1)
                    else:
                        return None
            elif (_hx_local_1 == 5):
                if (field1 == "shift"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.shift)
                elif (field1 == "slice"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.slice)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    if hasattr(o,field1):
                        return getattr(o,field1)
                    else:
                        return None
            elif (_hx_local_1 == 7):
                if (field1 == "indexOf"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.indexOf)
                elif (field1 == "reverse"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.reverse)
                elif (field1 == "unshift"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.unshift)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    if hasattr(o,field1):
                        return getattr(o,field1)
                    else:
                        return None
            elif (_hx_local_1 == 3):
                if (field1 == "map"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.map)
                elif (field1 == "pop"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.pop)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    if hasattr(o,field1):
                        return getattr(o,field1)
                    else:
                        return None
            elif (_hx_local_1 == 8):
                if (field1 == "contains"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.contains)
                elif (field1 == "iterator"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.iterator)
                elif (field1 == "toString"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.toString)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    if hasattr(o,field1):
                        return getattr(o,field1)
                    else:
                        return None
            elif (_hx_local_1 == 16):
                if (field1 == "keyValueIterator"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.keyValueIterator)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    if hasattr(o,field1):
                        return getattr(o,field1)
                    else:
                        return None
            elif (_hx_local_1 == 6):
                if (field1 == "concat"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.concat)
                elif (field1 == "filter"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.filter)
                elif (field1 == "insert"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.insert)
                elif (field1 == "length"):
                    return len(o)
                elif (field1 == "remove"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.remove)
                elif (field1 == "splice"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.splice)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    if hasattr(o,field1):
                        return getattr(o,field1)
                    else:
                        return None
            else:
                field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                if hasattr(o,field1):
                    return getattr(o,field1)
                else:
                    return None
        else:
            field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
            if hasattr(o,field1):
                return getattr(o,field1)
            else:
                return None

    @staticmethod
    def getInstanceFields(c):
        f = (list(c._hx_fields) if (hasattr(c,"_hx_fields")) else [])
        if hasattr(c,"_hx_methods"):
            f = (f + c._hx_methods)
        sc = python_Boot.getSuperClass(c)
        if (sc is None):
            return f
        else:
            scArr = python_Boot.getInstanceFields(sc)
            scMap = set(scArr)
            _g = 0
            while (_g < len(f)):
                f1 = (f[_g] if _g >= 0 and _g < len(f) else None)
                _g = (_g + 1)
                if (not (f1 in scMap)):
                    scArr.append(f1)
            return scArr

    @staticmethod
    def getSuperClass(c):
        if (c is None):
            return None
        try:
            if hasattr(c,"_hx_super"):
                return c._hx_super
            return None
        except BaseException as _g:
            None
        return None

    @staticmethod
    def getClassFields(c):
        if hasattr(c,"_hx_statics"):
            x = c._hx_statics
            return list(x)
        else:
            return []

    @staticmethod
    def unhandleKeywords(name):
        if (HxString.substr(name,0,python_Boot.prefixLength) == "_hx_"):
            real = HxString.substr(name,python_Boot.prefixLength,None)
            if (real in python_Boot.keywords):
                return real
        return name
python_Boot._hx_class = python_Boot


class python_io_IoTools:
    _hx_class_name = "python.io.IoTools"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["createFileInputFromText", "createFileOutputFromText"]

    @staticmethod
    def createFileInputFromText(t):
        return sys_io_FileInput(python_io_FileTextInput(t))

    @staticmethod
    def createFileOutputFromText(t):
        return sys_io_FileOutput(python_io_FileTextOutput(t))
python_io_IoTools._hx_class = python_io_IoTools


class haxe_io_Input:
    _hx_class_name = "haxe.io.Input"
    _hx_is_interface = "False"
    __slots__ = ("bigEndian",)
    _hx_fields = ["bigEndian"]
    _hx_methods = ["set_bigEndian"]

    def set_bigEndian(self,b):
        self.bigEndian = b
        return b

haxe_io_Input._hx_class = haxe_io_Input


class python_io_NativeInput(haxe_io_Input):
    _hx_class_name = "python.io.NativeInput"
    _hx_is_interface = "False"
    __slots__ = ("stream", "wasEof")
    _hx_fields = ["stream", "wasEof"]
    _hx_methods = []
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = haxe_io_Input


    def __init__(self,s):
        self.wasEof = None
        self.stream = s
        self.set_bigEndian(False)
        self.wasEof = False
        if (not self.stream.readable()):
            raise haxe_Exception.thrown("Write-only stream")

python_io_NativeInput._hx_class = python_io_NativeInput


class python_io_IInput:
    _hx_class_name = "python.io.IInput"
    _hx_is_interface = "True"
    __slots__ = ("bigEndian",)
    _hx_fields = ["bigEndian"]
    _hx_methods = ["set_bigEndian"]
python_io_IInput._hx_class = python_io_IInput


class python_io_NativeTextInput(python_io_NativeInput):
    _hx_class_name = "python.io.NativeTextInput"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = []
    _hx_statics = []
    _hx_interfaces = [python_io_IInput]
    _hx_super = python_io_NativeInput


    def __init__(self,stream):
        super().__init__(stream)
python_io_NativeTextInput._hx_class = python_io_NativeTextInput


class python_io_IFileInput:
    _hx_class_name = "python.io.IFileInput"
    _hx_is_interface = "True"
    __slots__ = ()
    _hx_interfaces = [python_io_IInput]
python_io_IFileInput._hx_class = python_io_IFileInput


class python_io_FileTextInput(python_io_NativeTextInput):
    _hx_class_name = "python.io.FileTextInput"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = []
    _hx_statics = []
    _hx_interfaces = [python_io_IFileInput]
    _hx_super = python_io_NativeTextInput


    def __init__(self,stream):
        super().__init__(stream)
python_io_FileTextInput._hx_class = python_io_FileTextInput


class sys_io_FileInput(haxe_io_Input):
    _hx_class_name = "sys.io.FileInput"
    _hx_is_interface = "False"
    __slots__ = ("impl",)
    _hx_fields = ["impl"]
    _hx_methods = ["set_bigEndian"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = haxe_io_Input


    def __init__(self,impl):
        self.impl = impl

    def set_bigEndian(self,b):
        return self.impl.set_bigEndian(b)

sys_io_FileInput._hx_class = sys_io_FileInput


class haxe_io_Output:
    _hx_class_name = "haxe.io.Output"
    _hx_is_interface = "False"
    __slots__ = ("bigEndian",)
    _hx_fields = ["bigEndian"]
    _hx_methods = ["set_bigEndian"]

    def set_bigEndian(self,b):
        self.bigEndian = b
        return b

haxe_io_Output._hx_class = haxe_io_Output


class python_io_NativeOutput(haxe_io_Output):
    _hx_class_name = "python.io.NativeOutput"
    _hx_is_interface = "False"
    __slots__ = ("stream",)
    _hx_fields = ["stream"]
    _hx_methods = []
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = haxe_io_Output


    def __init__(self,stream):
        self.stream = None
        self.set_bigEndian(False)
        self.stream = stream
        if (not stream.writable()):
            raise haxe_Exception.thrown("Read only stream")

python_io_NativeOutput._hx_class = python_io_NativeOutput


class python_io_NativeTextOutput(python_io_NativeOutput):
    _hx_class_name = "python.io.NativeTextOutput"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = []
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = python_io_NativeOutput


    def __init__(self,stream):
        super().__init__(stream)
        if (not stream.writable()):
            raise haxe_Exception.thrown("Read only stream")
python_io_NativeTextOutput._hx_class = python_io_NativeTextOutput


class python_io_IOutput:
    _hx_class_name = "python.io.IOutput"
    _hx_is_interface = "True"
    __slots__ = ("bigEndian",)
    _hx_fields = ["bigEndian"]
    _hx_methods = ["set_bigEndian"]
python_io_IOutput._hx_class = python_io_IOutput


class python_io_IFileOutput:
    _hx_class_name = "python.io.IFileOutput"
    _hx_is_interface = "True"
    __slots__ = ()
    _hx_interfaces = [python_io_IOutput]
python_io_IFileOutput._hx_class = python_io_IFileOutput


class python_io_FileTextOutput(python_io_NativeTextOutput):
    _hx_class_name = "python.io.FileTextOutput"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = []
    _hx_statics = []
    _hx_interfaces = [python_io_IFileOutput]
    _hx_super = python_io_NativeTextOutput


    def __init__(self,stream):
        super().__init__(stream)
python_io_FileTextOutput._hx_class = python_io_FileTextOutput


class sys_io_FileOutput(haxe_io_Output):
    _hx_class_name = "sys.io.FileOutput"
    _hx_is_interface = "False"
    __slots__ = ("impl",)
    _hx_fields = ["impl"]
    _hx_methods = ["set_bigEndian"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = haxe_io_Output


    def __init__(self,impl):
        self.impl = impl

    def set_bigEndian(self,b):
        return self.impl.set_bigEndian(b)

sys_io_FileOutput._hx_class = sys_io_FileOutput


class Reflect:
    _hx_class_name = "Reflect"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["field", "setField", "compare", "isEnumValue", "makeVarArgs"]

    @staticmethod
    def field(o,field):
        return python_Boot.field(o,field)

    @staticmethod
    def setField(o,field,value):
        setattr(o,(("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field)),value)

    @staticmethod
    def compare(a,b):
        if ((a is None) and ((b is None))):
            return 0
        if (a is None):
            return 1
        elif (b is None):
            return -1
        elif HxOverrides.eq(a,b):
            return 0
        elif (a > b):
            return 1
        else:
            return -1

    @staticmethod
    def isEnumValue(v):
        if not HxOverrides.eq(v,Enum):
            return isinstance(v,Enum)
        else:
            return False

    @staticmethod
    def makeVarArgs(f):
        def _hx_local_0(*v):
            this1 = v
            return f((list(this1) if ((not Std.isOfType(this1,list))) else this1))
        return _hx_local_0
Reflect._hx_class = Reflect


class Std:
    _hx_class_name = "Std"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["downcast", "isOfType", "string"]

    @staticmethod
    def downcast(value,c):
        try:
            tmp = None
            if (not isinstance(value,c)):
                if c._hx_is_interface:
                    cls = c
                    loop = None
                    def _hx_local_1(intf):
                        f = (intf._hx_interfaces if (hasattr(intf,"_hx_interfaces")) else [])
                        if (f is not None):
                            _g = 0
                            while (_g < len(f)):
                                i = (f[_g] if _g >= 0 and _g < len(f) else None)
                                _g = (_g + 1)
                                if (i == cls):
                                    return True
                                else:
                                    l = loop(i)
                                    if l:
                                        return True
                            return False
                        else:
                            return False
                    loop = _hx_local_1
                    currentClass = value.__class__
                    result = False
                    while (currentClass is not None):
                        if loop(currentClass):
                            result = True
                            break
                        currentClass = python_Boot.getSuperClass(currentClass)
                    tmp = result
                else:
                    tmp = False
            else:
                tmp = True
            if tmp:
                return value
            else:
                return None
        except BaseException as _g:
            None
            return None

    @staticmethod
    def isOfType(v,t):
        if ((v is None) and ((t is None))):
            return False
        if (t is None):
            return False
        if (t == Dynamic):
            return (v is not None)
        isBool = isinstance(v,bool)
        if ((t == Bool) and isBool):
            return True
        if ((((not isBool) and (not (t == Bool))) and (t == Int)) and isinstance(v,int)):
            return True
        vIsFloat = isinstance(v,float)
        tmp = None
        tmp1 = None
        if (((not isBool) and vIsFloat) and (t == Int)):
            f = v
            tmp1 = (((f != Math.POSITIVE_INFINITY) and ((f != Math.NEGATIVE_INFINITY))) and (not python_lib_Math.isnan(f)))
        else:
            tmp1 = False
        if tmp1:
            tmp1 = None
            try:
                tmp1 = int(v)
            except BaseException as _g:
                None
                tmp1 = None
            tmp = (v == tmp1)
        else:
            tmp = False
        if ((tmp and ((v <= 2147483647))) and ((v >= -2147483648))):
            return True
        if (((not isBool) and (t == Float)) and isinstance(v,(float, int))):
            return True
        if (t == str):
            return isinstance(v,str)
        isEnumType = (t == Enum)
        if ((isEnumType and python_lib_Inspect.isclass(v)) and hasattr(v,"_hx_constructs")):
            return True
        if isEnumType:
            return False
        isClassType = (t == Class)
        if ((((isClassType and (not isinstance(v,Enum))) and python_lib_Inspect.isclass(v)) and hasattr(v,"_hx_class_name")) and (not hasattr(v,"_hx_constructs"))):
            return True
        if isClassType:
            return False
        tmp = None
        try:
            tmp = isinstance(v,t)
        except BaseException as _g:
            None
            tmp = False
        if tmp:
            return True
        if python_lib_Inspect.isclass(t):
            cls = t
            loop = None
            def _hx_local_1(intf):
                f = (intf._hx_interfaces if (hasattr(intf,"_hx_interfaces")) else [])
                if (f is not None):
                    _g = 0
                    while (_g < len(f)):
                        i = (f[_g] if _g >= 0 and _g < len(f) else None)
                        _g = (_g + 1)
                        if (i == cls):
                            return True
                        else:
                            l = loop(i)
                            if l:
                                return True
                    return False
                else:
                    return False
            loop = _hx_local_1
            currentClass = v.__class__
            result = False
            while (currentClass is not None):
                if loop(currentClass):
                    result = True
                    break
                currentClass = python_Boot.getSuperClass(currentClass)
            return result
        else:
            return False

    @staticmethod
    def string(s):
        return python_Boot.toString1(s,"")
Std._hx_class = Std


class Dynamic: pass


class Bool: pass


class Int: pass


class Float: pass


class Class: pass


class ANSI:
    _hx_class_name = "ANSI"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["ESCAPE", "BELL", "CSI", "attr", "values", "set", "available", "strip", "stripIfUnavailable", "aset", "detectSupport", "title", "sequences", "showCursor", "setY", "setXY", "setX", "saveCursor", "resetY", "reset", "moveUpReset", "moveUp", "moveRight", "moveLeft", "moveDownReset", "moveDown", "loadCursor", "insertLines", "insertLine", "insertChars", "insertChar", "hideCursor", "eraseLineToEnd", "eraseLineToCursor", "eraseLine", "eraseDisplayToEnd", "eraseDisplayToCursor", "eraseDisplay", "eraseChars", "eraseChar", "deleteLines", "deleteLine", "deleteChars", "deleteChar"]

    @staticmethod
    def aset(attributes):
        if (ANSI.strip or ((ANSI.stripIfUnavailable and (not ANSI.available)))):
            return ""
        tmp = ("\x1B" + "[")
        _g = []
        _g1 = 0
        while (_g1 < len(attributes)):
            arg = (attributes[_g1] if _g1 >= 0 and _g1 < len(attributes) else None)
            _g1 = (_g1 + 1)
            if (not Std.isOfType(arg,Attribute)):
                raise haxe_Exception.thrown(("Set argument is not an Attribute: " + Std.string(arg)))
            x = ANSI.values.get(arg)
            _g.append(x)
        return ((("null" if tmp is None else tmp) + HxOverrides.stringOrNull(";".join([python_Boot.toString1(x1,'') for x1 in _g]))) + "m")

    @staticmethod
    def detectSupport():
        _this = Sys.systemName().lower()
        startIndex = None
        if (((_this.find("window") if ((startIndex is None)) else HxString.indexOfImpl(_this,"window",startIndex))) == -1):
            result = -1
            try:
                process = sys_io_Process("tput",["colors"])
                result = process.exitCode()
                process.close()
            except BaseException as _g:
                None
            return (result == 0)
        else:
            return (Sys.getEnv("ANSICON") is not None)

    @staticmethod
    def title(_hx_str):
        if (ANSI.strip or ((ANSI.stripIfUnavailable and (not ANSI.available)))):
            return ""
        return ((("\x1B" + "]0;") + ("null" if _hx_str is None else _hx_str)) + "\x07")

    @staticmethod
    def showCursor():
        if (ANSI.strip or ((ANSI.stripIfUnavailable and (not ANSI.available)))):
            return ""
        return "\x1B[?25h"

    @staticmethod
    def setY(num = None):
        if (num is None):
            num = 1
        if (ANSI.strip or ((ANSI.stripIfUnavailable and (not ANSI.available)))):
            return ""
        return (("\x1B[" + Std.string(num)) + "d")

    @staticmethod
    def setXY(column,line):
        if (ANSI.strip or ((ANSI.stripIfUnavailable and (not ANSI.available)))):
            return ""
        return (((("\x1B[" + Std.string(line)) + ";") + Std.string(column)) + "H")

    @staticmethod
    def setX(num = None):
        if (num is None):
            num = 1
        if (ANSI.strip or ((ANSI.stripIfUnavailable and (not ANSI.available)))):
            return ""
        return (("\x1B[" + Std.string(num)) + "G")

    @staticmethod
    def saveCursor():
        if (ANSI.strip or ((ANSI.stripIfUnavailable and (not ANSI.available)))):
            return ""
        return "\x1B[s"

    @staticmethod
    def resetY(num = None):
        if (num is None):
            num = 1
        if (ANSI.strip or ((ANSI.stripIfUnavailable and (not ANSI.available)))):
            return ""
        return (("\x1B[" + Std.string(num)) + "H")

    @staticmethod
    def reset():
        if (ANSI.strip or ((ANSI.stripIfUnavailable and (not ANSI.available)))):
            return ""
        return "\x1B[H"

    @staticmethod
    def moveUpReset(num = None):
        if (num is None):
            num = 1
        if (ANSI.strip or ((ANSI.stripIfUnavailable and (not ANSI.available)))):
            return ""
        return (("\x1B[" + Std.string(num)) + "F")

    @staticmethod
    def moveUp(num = None):
        if (num is None):
            num = 1
        if (ANSI.strip or ((ANSI.stripIfUnavailable and (not ANSI.available)))):
            return ""
        return (("\x1B[" + Std.string(num)) + "A")

    @staticmethod
    def moveRight(num = None):
        if (num is None):
            num = 1
        if (ANSI.strip or ((ANSI.stripIfUnavailable and (not ANSI.available)))):
            return ""
        return (("\x1B[" + Std.string(num)) + "C")

    @staticmethod
    def moveLeft(num = None):
        if (num is None):
            num = 1
        if (ANSI.strip or ((ANSI.stripIfUnavailable and (not ANSI.available)))):
            return ""
        return (("\x1B[" + Std.string(num)) + "D")

    @staticmethod
    def moveDownReset(num = None):
        if (num is None):
            num = 1
        if (ANSI.strip or ((ANSI.stripIfUnavailable and (not ANSI.available)))):
            return ""
        return (("\x1B[" + Std.string(num)) + "E")

    @staticmethod
    def moveDown(num = None):
        if (num is None):
            num = 1
        if (ANSI.strip or ((ANSI.stripIfUnavailable and (not ANSI.available)))):
            return ""
        return (("\x1B[" + Std.string(num)) + "B")

    @staticmethod
    def loadCursor():
        if (ANSI.strip or ((ANSI.stripIfUnavailable and (not ANSI.available)))):
            return ""
        return "\x1B[u"

    @staticmethod
    def insertLines(num = None):
        if (num is None):
            num = 1
        if (ANSI.strip or ((ANSI.stripIfUnavailable and (not ANSI.available)))):
            return ""
        return (("\x1B[" + Std.string(num)) + "L")

    @staticmethod
    def insertLine():
        if (ANSI.strip or ((ANSI.stripIfUnavailable and (not ANSI.available)))):
            return ""
        return "\x1B[L"

    @staticmethod
    def insertChars(num = None):
        if (num is None):
            num = 1
        if (ANSI.strip or ((ANSI.stripIfUnavailable and (not ANSI.available)))):
            return ""
        return (("\x1B[" + Std.string(num)) + "@")

    @staticmethod
    def insertChar():
        if (ANSI.strip or ((ANSI.stripIfUnavailable and (not ANSI.available)))):
            return ""
        return "\x1B[@"

    @staticmethod
    def hideCursor():
        if (ANSI.strip or ((ANSI.stripIfUnavailable and (not ANSI.available)))):
            return ""
        return "\x1B[?25l"

    @staticmethod
    def eraseLineToEnd():
        if (ANSI.strip or ((ANSI.stripIfUnavailable and (not ANSI.available)))):
            return ""
        return "\x1B[K"

    @staticmethod
    def eraseLineToCursor():
        if (ANSI.strip or ((ANSI.stripIfUnavailable and (not ANSI.available)))):
            return ""
        return "\x1B[1K"

    @staticmethod
    def eraseLine():
        if (ANSI.strip or ((ANSI.stripIfUnavailable and (not ANSI.available)))):
            return ""
        return "\x1B[2K"

    @staticmethod
    def eraseDisplayToEnd():
        if (ANSI.strip or ((ANSI.stripIfUnavailable and (not ANSI.available)))):
            return ""
        return "\x1B[J"

    @staticmethod
    def eraseDisplayToCursor():
        if (ANSI.strip or ((ANSI.stripIfUnavailable and (not ANSI.available)))):
            return ""
        return "\x1B[1J"

    @staticmethod
    def eraseDisplay():
        if (ANSI.strip or ((ANSI.stripIfUnavailable and (not ANSI.available)))):
            return ""
        return "\x1B[2J"

    @staticmethod
    def eraseChars(num = None):
        if (num is None):
            num = 1
        if (ANSI.strip or ((ANSI.stripIfUnavailable and (not ANSI.available)))):
            return ""
        return (("\x1B[" + Std.string(num)) + "X")

    @staticmethod
    def eraseChar():
        if (ANSI.strip or ((ANSI.stripIfUnavailable and (not ANSI.available)))):
            return ""
        return "\x1B[X"

    @staticmethod
    def deleteLines(num = None):
        if (num is None):
            num = 1
        if (ANSI.strip or ((ANSI.stripIfUnavailable and (not ANSI.available)))):
            return ""
        return (("\x1B[" + Std.string(num)) + "M")

    @staticmethod
    def deleteLine():
        if (ANSI.strip or ((ANSI.stripIfUnavailable and (not ANSI.available)))):
            return ""
        return "\x1B[M"

    @staticmethod
    def deleteChars(num = None):
        if (num is None):
            num = 1
        if (ANSI.strip or ((ANSI.stripIfUnavailable and (not ANSI.available)))):
            return ""
        return (("\x1B[" + Std.string(num)) + "P")

    @staticmethod
    def deleteChar():
        if (ANSI.strip or ((ANSI.stripIfUnavailable and (not ANSI.available)))):
            return ""
        return "\x1B[P"
ANSI._hx_class = ANSI


class RunTests:
    _hx_class_name = "RunTests"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["main"]

    @staticmethod
    def main():
        this1 = [tink_unit_TestSuiteBuilder0(Test(),None)]
        tink_testrunner_Runner.run(this1).handle(tink_testrunner_Runner.exit)
RunTests._hx_class = RunTests


class Test:
    _hx_class_name = "Test"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_methods = ["quick_test"]

    def __init__(self):
        pass

    def quick_test(self,asserts):
        assertion = None
        try:
            d = None
            z = (Reflect.field(d,"x") * Reflect.field(d,"x"))
            assertion = tink_testrunner__Assertion_AssertionResult_Impl_.ofBool(True)
        except BaseException as _g:
            e = haxe_Exception.caught(_g)
            print(str(e))
            assertion = tink_testrunner__Assertion_AssertionResult_Impl_.ofBool(False)
        assertion1 = tink_testrunner_Assertion(assertion,"({\n\tvar d:Dynamic = null;\n\tvar z = d.x * d.x;\n\tNoise;\n}).attempt(true)",_hx_AnonObject({'fileName': "tests/RunTests.hx", 'lineNumber': 23, 'className': "Test", 'methodName': "quick_test"}))
        asserts.trigger.handlers.invoke(tink_streams_Yield.Data(assertion1))
        shouldFail = assertion1
        lh = None
        try:
            lh = True
        except BaseException as _g:
            lh = False
        rh = True
        assertion = tink_testrunner_Assertion(tink_testrunner__Assertion_AssertionResult_Impl_.ofBool((lh == rh)),((((((("attempt(39 / 1) == true" + " (") + Std.string(lh)) + " ") + "==") + " ") + Std.string(rh)) + ")"),_hx_AnonObject({'fileName': "tests/RunTests.hx", 'lineNumber': 28, 'className': "Test", 'methodName': "quick_test"}))
        asserts.trigger.handlers.invoke(tink_streams_Yield.Data(assertion))
        shouldPass = assertion
        lh = (not tink_core_OutcomeTools.isSuccess(shouldFail.holds))
        rh = tink_core_OutcomeTools.isSuccess(shouldPass.holds)
        assertion = tink_testrunner_Assertion(tink_testrunner__Assertion_AssertionResult_Impl_.ofBool((lh and rh)),((((((("!shouldFail.holds.toBool() && shouldPass.holds.toBool()" + " (") + Std.string(lh)) + " ") + "&&") + " ") + Std.string(rh)) + ")"),_hx_AnonObject({'fileName': "tests/RunTests.hx", 'lineNumber': 29, 'className': "Test", 'methodName': "quick_test"}))
        asserts.trigger.handlers.invoke(tink_streams_Yield.Data(assertion))
        return assertion

Test._hx_class = Test


class StringBuf:
    _hx_class_name = "StringBuf"
    _hx_is_interface = "False"
    __slots__ = ("b",)
    _hx_fields = ["b"]
    _hx_methods = ["get_length"]

    def __init__(self):
        self.b = python_lib_io_StringIO()

    def get_length(self):
        pos = self.b.tell()
        self.b.seek(0,2)
        _hx_len = self.b.tell()
        self.b.seek(pos,0)
        return _hx_len

StringBuf._hx_class = StringBuf


class StringTools:
    _hx_class_name = "StringTools"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["lpad", "rpad"]

    @staticmethod
    def lpad(s,c,l):
        if (len(c) <= 0):
            return s
        buf = StringBuf()
        l = (l - len(s))
        while (buf.get_length() < l):
            s1 = Std.string(c)
            buf.b.write(s1)
        s1 = Std.string(s)
        buf.b.write(s1)
        return buf.b.getvalue()

    @staticmethod
    def rpad(s,c,l):
        if (len(c) <= 0):
            return s
        buf = StringBuf()
        s1 = Std.string(s)
        buf.b.write(s1)
        while (buf.get_length() < l):
            s = Std.string(c)
            buf.b.write(s)
        return buf.b.getvalue()
StringTools._hx_class = StringTools


class Type:
    _hx_class_name = "Type"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["getClass", "getClassName"]

    @staticmethod
    def getClass(o):
        if (o is None):
            return None
        o1 = o
        if ((o1 is not None) and ((HxOverrides.eq(o1,str) or python_lib_Inspect.isclass(o1)))):
            return None
        if isinstance(o,_hx_AnonObject):
            return None
        if hasattr(o,"_hx_class"):
            return o._hx_class
        if hasattr(o,"__class__"):
            return o.__class__
        else:
            return None

    @staticmethod
    def getClassName(c):
        if hasattr(c,"_hx_class_name"):
            return c._hx_class_name
        else:
            if (c == list):
                return "Array"
            if (c == Math):
                return "Math"
            if (c == str):
                return "String"
            try:
                return c.__name__
            except BaseException as _g:
                None
                return None
Type._hx_class = Type


class bp_test_Utils:
    _hx_class_name = "bp.test.Utils"
    _hx_is_interface = "False"
    __slots__ = ()
bp_test_Utils._hx_class = bp_test_Utils

class haxe_StackItem(Enum):
    __slots__ = ()
    _hx_class_name = "haxe.StackItem"
    _hx_constructs = ["CFunction", "Module", "FilePos", "Method", "LocalFunction"]

    @staticmethod
    def Module(m):
        return haxe_StackItem("Module", 1, (m,))

    @staticmethod
    def FilePos(s,file,line,column = None):
        return haxe_StackItem("FilePos", 2, (s,file,line,column))

    @staticmethod
    def Method(classname,method):
        return haxe_StackItem("Method", 3, (classname,method))

    @staticmethod
    def LocalFunction(v = None):
        return haxe_StackItem("LocalFunction", 4, (v,))
haxe_StackItem.CFunction = haxe_StackItem("CFunction", 0, ())
haxe_StackItem._hx_class = haxe_StackItem


class haxe_EntryPoint:
    _hx_class_name = "haxe.EntryPoint"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["pending", "threadCount", "processEvents", "run"]

    @staticmethod
    def processEvents():
        while True:
            _this = haxe_EntryPoint.pending
            f = (None if ((len(_this) == 0)) else _this.pop(0))
            if (f is None):
                break
            f()
        time = haxe_MainLoop.tick()
        if ((not haxe_MainLoop.hasEvents()) and ((haxe_EntryPoint.threadCount == 0))):
            return -1
        return time

    @staticmethod
    def run():
        while True:
            nextTick = haxe_EntryPoint.processEvents()
            if (nextTick < 0):
                break
            tmp = (nextTick > 0)
haxe_EntryPoint._hx_class = haxe_EntryPoint


class haxe_Exception(Exception):
    _hx_class_name = "haxe.Exception"
    _hx_is_interface = "False"
    __slots__ = ("_hx___nativeStack", "_hx___skipStack", "_hx___nativeException", "_hx___previousException")
    _hx_fields = ["__nativeStack", "__skipStack", "__nativeException", "__previousException"]
    _hx_methods = ["unwrap", "get_native"]
    _hx_statics = ["caught", "thrown"]
    _hx_interfaces = []
    _hx_super = Exception


    def __init__(self,message,previous = None,native = None):
        self._hx___previousException = None
        self._hx___nativeException = None
        self._hx___nativeStack = None
        self._hx___skipStack = 0
        super().__init__(message)
        self._hx___previousException = previous
        if ((native is not None) and Std.isOfType(native,BaseException)):
            self._hx___nativeException = native
            self._hx___nativeStack = haxe_NativeStackTrace.exceptionStack()
        else:
            self._hx___nativeException = self
            infos = python_lib_Traceback.extract_stack()
            if (len(infos) != 0):
                infos.pop()
            infos.reverse()
            self._hx___nativeStack = infos

    def unwrap(self):
        return self._hx___nativeException

    def get_native(self):
        return self._hx___nativeException

    @staticmethod
    def caught(value):
        if Std.isOfType(value,haxe_Exception):
            return value
        elif Std.isOfType(value,BaseException):
            return haxe_Exception(str(value),None,value)
        else:
            return haxe_ValueException(value,None,value)

    @staticmethod
    def thrown(value):
        if Std.isOfType(value,haxe_Exception):
            return value.get_native()
        elif Std.isOfType(value,BaseException):
            return value
        else:
            e = haxe_ValueException(value)
            e._hx___skipStack = (e._hx___skipStack + 1)
            return e

haxe_Exception._hx_class = haxe_Exception


class haxe_MainEvent:
    _hx_class_name = "haxe.MainEvent"
    _hx_is_interface = "False"
    __slots__ = ("f", "prev", "next", "isBlocking", "nextRun", "priority")
    _hx_fields = ["f", "prev", "next", "isBlocking", "nextRun", "priority"]
    _hx_methods = ["delay", "stop"]

    def __init__(self,f,p):
        self.next = None
        self.prev = None
        self.isBlocking = True
        self.f = f
        self.priority = p
        self.nextRun = Math.NEGATIVE_INFINITY

    def delay(self,t):
        self.nextRun = (Math.NEGATIVE_INFINITY if ((t is None)) else (python_lib_Timeit.default_timer() + t))

    def stop(self):
        if (self.f is None):
            return
        self.f = None
        self.nextRun = Math.NEGATIVE_INFINITY
        if (self.prev is None):
            haxe_MainLoop.pending = self.next
        else:
            self.prev.next = self.next
        if (self.next is not None):
            self.next.prev = self.prev

haxe_MainEvent._hx_class = haxe_MainEvent


class haxe_MainLoop:
    _hx_class_name = "haxe.MainLoop"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["pending", "hasEvents", "add", "sortEvents", "tick"]
    pending = None

    @staticmethod
    def hasEvents():
        p = haxe_MainLoop.pending
        while (p is not None):
            if p.isBlocking:
                return True
            p = p.next
        return False

    @staticmethod
    def add(f,priority = None):
        if (priority is None):
            priority = 0
        if (f is None):
            raise haxe_Exception.thrown("Event function is null")
        e = haxe_MainEvent(f,priority)
        head = haxe_MainLoop.pending
        if (head is not None):
            head.prev = e
        e.next = head
        haxe_MainLoop.pending = e
        return e

    @staticmethod
    def sortEvents():
        _hx_list = haxe_MainLoop.pending
        if (_hx_list is None):
            return
        insize = 1
        nmerges = None
        psize = 0
        qsize = 0
        p = None
        q = None
        e = None
        tail = None
        while True:
            p = _hx_list
            _hx_list = None
            tail = None
            nmerges = 0
            while (p is not None):
                nmerges = (nmerges + 1)
                q = p
                psize = 0
                _g = 0
                _g1 = insize
                while (_g < _g1):
                    i = _g
                    _g = (_g + 1)
                    psize = (psize + 1)
                    q = q.next
                    if (q is None):
                        break
                qsize = insize
                while ((psize > 0) or (((qsize > 0) and ((q is not None))))):
                    if (psize == 0):
                        e = q
                        q = q.next
                        qsize = (qsize - 1)
                    elif (((qsize == 0) or ((q is None))) or (((p.priority > q.priority) or (((p.priority == q.priority) and ((p.nextRun <= q.nextRun))))))):
                        e = p
                        p = p.next
                        psize = (psize - 1)
                    else:
                        e = q
                        q = q.next
                        qsize = (qsize - 1)
                    if (tail is not None):
                        tail.next = e
                    else:
                        _hx_list = e
                    e.prev = tail
                    tail = e
                p = q
            tail.next = None
            if (nmerges <= 1):
                break
            insize = (insize * 2)
        _hx_list.prev = None
        haxe_MainLoop.pending = _hx_list

    @staticmethod
    def tick():
        haxe_MainLoop.sortEvents()
        e = haxe_MainLoop.pending
        now = python_lib_Timeit.default_timer()
        wait = 1e9
        while (e is not None):
            next = e.next
            wt = (e.nextRun - now)
            if (wt <= 0):
                wait = 0
                if (e.f is not None):
                    e.f()
            elif (wait > wt):
                wait = wt
            e = next
        return wait
haxe_MainLoop._hx_class = haxe_MainLoop


class haxe_NativeStackTrace:
    _hx_class_name = "haxe.NativeStackTrace"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["saveStack", "exceptionStack"]

    @staticmethod
    def saveStack(exception):
        pass

    @staticmethod
    def exceptionStack():
        exc = python_lib_Sys.exc_info()
        if (exc[2] is not None):
            infos = python_lib_Traceback.extract_tb(exc[2])
            infos.reverse()
            return infos
        else:
            return []
haxe_NativeStackTrace._hx_class = haxe_NativeStackTrace


class haxe_Timer:
    _hx_class_name = "haxe.Timer"
    _hx_is_interface = "False"
    _hx_fields = ["event"]
    _hx_methods = ["stop", "run"]
    _hx_statics = ["delay"]

    def __init__(self,time_ms):
        self.event = None
        _gthis = self
        dt = (time_ms / 1000)
        def _hx_local_2():
            _hx_local_0 = _gthis.event
            _hx_local_1 = _hx_local_0.nextRun
            _hx_local_0.nextRun = (_hx_local_1 + dt)
            _hx_local_0.nextRun
            _gthis.run()
        self.event = haxe_MainLoop.add(_hx_local_2)
        self.event.delay(dt)

    def stop(self):
        if (self.event is not None):
            self.event.stop()
            self.event = None

    def run(self):
        pass

    @staticmethod
    def delay(f,time_ms):
        t = haxe_Timer(time_ms)
        def _hx_local_0():
            t.stop()
            f()
        t.run = _hx_local_0
        return t

haxe_Timer._hx_class = haxe_Timer


class haxe_ValueException(haxe_Exception):
    _hx_class_name = "haxe.ValueException"
    _hx_is_interface = "False"
    __slots__ = ("value",)
    _hx_fields = ["value"]
    _hx_methods = ["unwrap"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = haxe_Exception


    def __init__(self,value,previous = None,native = None):
        self.value = None
        super().__init__(Std.string(value),previous,native)
        self.value = value

    def unwrap(self):
        return self.value

haxe_ValueException._hx_class = haxe_ValueException


class haxe_ds_BalancedTree:
    _hx_class_name = "haxe.ds.BalancedTree"
    _hx_is_interface = "False"
    __slots__ = ("root",)
    _hx_fields = ["root"]
    _hx_methods = ["set", "get", "setLoop", "balance", "compare"]
    _hx_interfaces = [haxe_IMap]

    def __init__(self):
        self.root = None

    def set(self,key,value):
        self.root = self.setLoop(key,value,self.root)

    def get(self,key):
        node = self.root
        while (node is not None):
            c = self.compare(key,node.key)
            if (c == 0):
                return node.value
            if (c < 0):
                node = node.left
            else:
                node = node.right
        return None

    def setLoop(self,k,v,node):
        if (node is None):
            return haxe_ds_TreeNode(None,k,v,None)
        c = self.compare(k,node.key)
        if (c == 0):
            return haxe_ds_TreeNode(node.left,k,v,node.right,(0 if ((node is None)) else node._height))
        elif (c < 0):
            nl = self.setLoop(k,v,node.left)
            return self.balance(nl,node.key,node.value,node.right)
        else:
            nr = self.setLoop(k,v,node.right)
            return self.balance(node.left,node.key,node.value,nr)

    def balance(self,l,k,v,r):
        hl = (0 if ((l is None)) else l._height)
        hr = (0 if ((r is None)) else r._height)
        if (hl > ((hr + 2))):
            _this = l.left
            _this1 = l.right
            if (((0 if ((_this is None)) else _this._height)) >= ((0 if ((_this1 is None)) else _this1._height))):
                return haxe_ds_TreeNode(l.left,l.key,l.value,haxe_ds_TreeNode(l.right,k,v,r))
            else:
                return haxe_ds_TreeNode(haxe_ds_TreeNode(l.left,l.key,l.value,l.right.left),l.right.key,l.right.value,haxe_ds_TreeNode(l.right.right,k,v,r))
        elif (hr > ((hl + 2))):
            _this = r.right
            _this1 = r.left
            if (((0 if ((_this is None)) else _this._height)) > ((0 if ((_this1 is None)) else _this1._height))):
                return haxe_ds_TreeNode(haxe_ds_TreeNode(l,k,v,r.left),r.key,r.value,r.right)
            else:
                return haxe_ds_TreeNode(haxe_ds_TreeNode(l,k,v,r.left.left),r.left.key,r.left.value,haxe_ds_TreeNode(r.left.right,r.key,r.value,r.right))
        else:
            return haxe_ds_TreeNode(l,k,v,r,(((hl if ((hl > hr)) else hr)) + 1))

    def compare(self,k1,k2):
        return Reflect.compare(k1,k2)

haxe_ds_BalancedTree._hx_class = haxe_ds_BalancedTree


class haxe_ds_TreeNode:
    _hx_class_name = "haxe.ds.TreeNode"
    _hx_is_interface = "False"
    __slots__ = ("left", "right", "key", "value", "_height")
    _hx_fields = ["left", "right", "key", "value", "_height"]

    def __init__(self,l,k,v,r,h = None):
        if (h is None):
            h = -1
        self._height = None
        self.left = l
        self.key = k
        self.value = v
        self.right = r
        if (h == -1):
            tmp = None
            _this = self.left
            _this1 = self.right
            if (((0 if ((_this is None)) else _this._height)) > ((0 if ((_this1 is None)) else _this1._height))):
                _this = self.left
                tmp = (0 if ((_this is None)) else _this._height)
            else:
                _this = self.right
                tmp = (0 if ((_this is None)) else _this._height)
            self._height = (tmp + 1)
        else:
            self._height = h

haxe_ds_TreeNode._hx_class = haxe_ds_TreeNode

class haxe_ds_Either(Enum):
    __slots__ = ()
    _hx_class_name = "haxe.ds.Either"
    _hx_constructs = ["Left", "Right"]

    @staticmethod
    def Left(v):
        return haxe_ds_Either("Left", 0, (v,))

    @staticmethod
    def Right(v):
        return haxe_ds_Either("Right", 1, (v,))
haxe_ds_Either._hx_class = haxe_ds_Either


class haxe_ds_EnumValueMap(haxe_ds_BalancedTree):
    _hx_class_name = "haxe.ds.EnumValueMap"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["compare", "compareArgs", "compareArg"]
    _hx_statics = []
    _hx_interfaces = [haxe_IMap]
    _hx_super = haxe_ds_BalancedTree


    def __init__(self):
        super().__init__()

    def compare(self,k1,k2):
        d = (k1.index - k2.index)
        if (d != 0):
            return d
        p1 = list(k1.params)
        p2 = list(k2.params)
        if ((len(p1) == 0) and ((len(p2) == 0))):
            return 0
        return self.compareArgs(p1,p2)

    def compareArgs(self,a1,a2):
        ld = (len(a1) - len(a2))
        if (ld != 0):
            return ld
        _g = 0
        _g1 = len(a1)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            d = self.compareArg((a1[i] if i >= 0 and i < len(a1) else None),(a2[i] if i >= 0 and i < len(a2) else None))
            if (d != 0):
                return d
        return 0

    def compareArg(self,v1,v2):
        if (Reflect.isEnumValue(v1) and Reflect.isEnumValue(v2)):
            return self.compare(v1,v2)
        elif (Std.isOfType(v1,list) and Std.isOfType(v2,list)):
            return self.compareArgs(v1,v2)
        else:
            return Reflect.compare(v1,v2)

haxe_ds_EnumValueMap._hx_class = haxe_ds_EnumValueMap


class haxe_ds_ObjectMap:
    _hx_class_name = "haxe.ds.ObjectMap"
    _hx_is_interface = "False"
    __slots__ = ("h",)
    _hx_fields = ["h"]
    _hx_interfaces = [haxe_IMap]

    def __init__(self):
        self.h = dict()

haxe_ds_ObjectMap._hx_class = haxe_ds_ObjectMap

class haxe_ds_Option(Enum):
    __slots__ = ()
    _hx_class_name = "haxe.ds.Option"
    _hx_constructs = ["Some", "None"]

    @staticmethod
    def Some(v):
        return haxe_ds_Option("Some", 0, (v,))
haxe_ds_Option._hx_None = haxe_ds_Option("None", 1, ())
haxe_ds_Option._hx_class = haxe_ds_Option


class haxe_iterators_ArrayIterator:
    _hx_class_name = "haxe.iterators.ArrayIterator"
    _hx_is_interface = "False"
    __slots__ = ("array", "current")
    _hx_fields = ["array", "current"]
    _hx_methods = ["hasNext", "next"]

    def __init__(self,array):
        self.current = 0
        self.array = array

    def hasNext(self):
        return (self.current < len(self.array))

    def next(self):
        def _hx_local_3():
            def _hx_local_2():
                _hx_local_0 = self
                _hx_local_1 = _hx_local_0.current
                _hx_local_0.current = (_hx_local_1 + 1)
                return _hx_local_1
            return python_internal_ArrayImpl._get(self.array, _hx_local_2())
        return _hx_local_3()

haxe_iterators_ArrayIterator._hx_class = haxe_iterators_ArrayIterator


class haxe_iterators_ArrayKeyValueIterator:
    _hx_class_name = "haxe.iterators.ArrayKeyValueIterator"
    _hx_is_interface = "False"
    __slots__ = ("current", "array")
    _hx_fields = ["current", "array"]
    _hx_methods = ["hasNext", "next"]

    def __init__(self,array):
        self.current = 0
        self.array = array

    def hasNext(self):
        return (self.current < len(self.array))

    def next(self):
        def _hx_local_3():
            def _hx_local_2():
                _hx_local_0 = self
                _hx_local_1 = _hx_local_0.current
                _hx_local_0.current = (_hx_local_1 + 1)
                return _hx_local_1
            return _hx_AnonObject({'value': python_internal_ArrayImpl._get(self.array, self.current), 'key': _hx_local_2()})
        return _hx_local_3()

haxe_iterators_ArrayKeyValueIterator._hx_class = haxe_iterators_ArrayKeyValueIterator


class haxe_macro_Printer:
    _hx_class_name = "haxe.macro.Printer"
    _hx_is_interface = "False"
    __slots__ = ("tabs", "tabString")
    _hx_fields = ["tabs", "tabString"]

    def __init__(self,tabString = None):
        if (tabString is None):
            tabString = "\t"
        self.tabs = ""
        self.tabString = tabString

haxe_macro_Printer._hx_class = haxe_macro_Printer


class python_Lib:
    _hx_class_name = "python.Lib"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["lineEnd", "printString"]

    @staticmethod
    def printString(_hx_str):
        encoding = "utf-8"
        if (encoding is None):
            encoding = "utf-8"
        python_lib_Sys.stdout.buffer.write(_hx_str.encode(encoding, "strict"))
        python_lib_Sys.stdout.flush()
python_Lib._hx_class = python_Lib


class python_internal_ArrayImpl:
    _hx_class_name = "python.internal.ArrayImpl"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["concat", "copy", "iterator", "keyValueIterator", "indexOf", "lastIndexOf", "join", "toString", "pop", "push", "unshift", "remove", "contains", "shift", "slice", "sort", "splice", "map", "filter", "insert", "reverse", "_get", "_set"]

    @staticmethod
    def concat(a1,a2):
        return (a1 + a2)

    @staticmethod
    def copy(x):
        return list(x)

    @staticmethod
    def iterator(x):
        return python_HaxeIterator(x.__iter__())

    @staticmethod
    def keyValueIterator(x):
        return haxe_iterators_ArrayKeyValueIterator(x)

    @staticmethod
    def indexOf(a,x,fromIndex = None):
        _hx_len = len(a)
        l = (0 if ((fromIndex is None)) else ((_hx_len + fromIndex) if ((fromIndex < 0)) else fromIndex))
        if (l < 0):
            l = 0
        _g = l
        _g1 = _hx_len
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            if HxOverrides.eq(a[i],x):
                return i
        return -1

    @staticmethod
    def lastIndexOf(a,x,fromIndex = None):
        _hx_len = len(a)
        l = (_hx_len if ((fromIndex is None)) else (((_hx_len + fromIndex) + 1) if ((fromIndex < 0)) else (fromIndex + 1)))
        if (l > _hx_len):
            l = _hx_len
        while True:
            l = (l - 1)
            tmp = l
            if (not ((tmp > -1))):
                break
            if HxOverrides.eq(a[l],x):
                return l
        return -1

    @staticmethod
    def join(x,sep):
        return sep.join([python_Boot.toString1(x1,'') for x1 in x])

    @staticmethod
    def toString(x):
        return (("[" + HxOverrides.stringOrNull(",".join([python_Boot.toString1(x1,'') for x1 in x]))) + "]")

    @staticmethod
    def pop(x):
        if (len(x) == 0):
            return None
        else:
            return x.pop()

    @staticmethod
    def push(x,e):
        x.append(e)
        return len(x)

    @staticmethod
    def unshift(x,e):
        x.insert(0, e)

    @staticmethod
    def remove(x,e):
        try:
            x.remove(e)
            return True
        except BaseException as _g:
            None
            return False

    @staticmethod
    def contains(x,e):
        return (e in x)

    @staticmethod
    def shift(x):
        if (len(x) == 0):
            return None
        return x.pop(0)

    @staticmethod
    def slice(x,pos,end = None):
        return x[pos:end]

    @staticmethod
    def sort(x,f):
        x.sort(key= python_lib_Functools.cmp_to_key(f))

    @staticmethod
    def splice(x,pos,_hx_len):
        if (pos < 0):
            pos = (len(x) + pos)
        if (pos < 0):
            pos = 0
        res = x[pos:(pos + _hx_len)]
        del x[pos:(pos + _hx_len)]
        return res

    @staticmethod
    def map(x,f):
        return list(map(f,x))

    @staticmethod
    def filter(x,f):
        return list(filter(f,x))

    @staticmethod
    def insert(a,pos,x):
        a.insert(pos, x)

    @staticmethod
    def reverse(a):
        a.reverse()

    @staticmethod
    def _get(x,idx):
        if ((idx > -1) and ((idx < len(x)))):
            return x[idx]
        else:
            return None

    @staticmethod
    def _set(x,idx,v):
        l = len(x)
        while (l < idx):
            x.append(None)
            l = (l + 1)
        if (l == idx):
            x.append(v)
        else:
            x[idx] = v
        return v
python_internal_ArrayImpl._hx_class = python_internal_ArrayImpl


class HxOverrides:
    _hx_class_name = "HxOverrides"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["iterator", "eq", "stringOrNull"]

    @staticmethod
    def iterator(x):
        if isinstance(x,list):
            return haxe_iterators_ArrayIterator(x)
        return x.iterator()

    @staticmethod
    def eq(a,b):
        if (isinstance(a,list) or isinstance(b,list)):
            return a is b
        return (a == b)

    @staticmethod
    def stringOrNull(s):
        if (s is None):
            return "null"
        else:
            return s
HxOverrides._hx_class = HxOverrides


class python_internal_MethodClosure:
    _hx_class_name = "python.internal.MethodClosure"
    _hx_is_interface = "False"
    __slots__ = ("obj", "func")
    _hx_fields = ["obj", "func"]
    _hx_methods = ["__call__"]

    def __init__(self,obj,func):
        self.obj = obj
        self.func = func

    def __call__(self,*args):
        return self.func(self.obj,*args)

python_internal_MethodClosure._hx_class = python_internal_MethodClosure


class tink_core_Annex:
    _hx_class_name = "tink.core.Annex"
    _hx_is_interface = "False"
    __slots__ = ("target", "registry")
    _hx_fields = ["target", "registry"]

    def __init__(self,target):
        self.target = target
        self.registry = haxe_ds_ObjectMap()

tink_core_Annex._hx_class = tink_core_Annex


class tink_core__Callback_Callback_Impl_:
    _hx_class_name = "tink.core._Callback.Callback_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["_new", "toFunction", "depth", "MAX_DEPTH", "invoke", "ignore", "fromNiladic", "fromMany", "defer"]

    @staticmethod
    def _new(f):
        this1 = f
        return this1

    @staticmethod
    def toFunction(this1):
        return this1

    @staticmethod
    def invoke(this1,data):
        if (tink_core__Callback_Callback_Impl_.depth < 200):
            _hx_local_0 = tink_core__Callback_Callback_Impl_
            _hx_local_1 = _hx_local_0.depth
            _hx_local_0.depth = (_hx_local_1 + 1)
            _hx_local_1
            this1(data)
            _hx_local_2 = tink_core__Callback_Callback_Impl_
            _hx_local_3 = _hx_local_2.depth
            _hx_local_2.depth = (_hx_local_3 - 1)
            _hx_local_3
        else:
            _e = this1
            def _hx_local_4(data):
                tink_core__Callback_Callback_Impl_.invoke(_e,data)
            _g = _hx_local_4
            data1 = data
            def _hx_local_5():
                _g(data1)
            tink_core__Callback_Callback_Impl_.defer(_hx_local_5)

    @staticmethod
    def ignore(cb):
        def _hx_local_0(_):
            tink_core__Callback_Callback_Impl_.invoke(cb,tink_core_Noise.Noise)
        return _hx_local_0

    @staticmethod
    def fromNiladic(f):
        def _hx_local_0(_):
            f()
        return _hx_local_0

    @staticmethod
    def fromMany(callbacks):
        def _hx_local_0(v):
            _g = 0
            while (_g < len(callbacks)):
                callback = (callbacks[_g] if _g >= 0 and _g < len(callbacks) else None)
                _g = (_g + 1)
                tink_core__Callback_Callback_Impl_.invoke(callback,v)
        return _hx_local_0

    @staticmethod
    def defer(f):
        haxe_Timer.delay(f,0)
tink_core__Callback_Callback_Impl_._hx_class = tink_core__Callback_Callback_Impl_


class tink_core_LinkObject:
    _hx_class_name = "tink.core.LinkObject"
    _hx_is_interface = "True"
    __slots__ = ()
    _hx_methods = ["cancel"]
tink_core_LinkObject._hx_class = tink_core_LinkObject


class tink_core__Callback_CallbackLink_Impl_:
    _hx_class_name = "tink.core._Callback.CallbackLink_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["_new", "cancel", "dissolve", "noop", "toFunction", "toCallback", "fromFunction", "join", "fromMany"]

    @staticmethod
    def _new(link):
        this1 = tink_core_SimpleLink(link)
        return this1

    @staticmethod
    def cancel(this1):
        if (this1 is not None):
            this1.cancel()

    @staticmethod
    def dissolve(this1):
        if (this1 is not None):
            this1.cancel()

    @staticmethod
    def noop():
        pass

    @staticmethod
    def toFunction(this1):
        if (this1 is None):
            return tink_core__Callback_CallbackLink_Impl_.noop
        else:
            return this1.cancel

    @staticmethod
    def toCallback(this1):
        def _hx_local_0(_):
            this1.cancel()
        return _hx_local_0

    @staticmethod
    def fromFunction(f):
        this1 = tink_core_SimpleLink(f)
        return this1

    @staticmethod
    def join(a,b):
        return tink_core__Callback_LinkPair(a,b)

    @staticmethod
    def fromMany(callbacks):
        def _hx_local_1():
            nonlocal callbacks
            if (callbacks is not None):
                _g = 0
                while (_g < len(callbacks)):
                    cb = (callbacks[_g] if _g >= 0 and _g < len(callbacks) else None)
                    _g = (_g + 1)
                    if (cb is not None):
                        cb.cancel()
            else:
                callbacks = None
        this1 = tink_core_SimpleLink(_hx_local_1)
        return this1
tink_core__Callback_CallbackLink_Impl_._hx_class = tink_core__Callback_CallbackLink_Impl_


class tink_core_SimpleLink:
    _hx_class_name = "tink.core.SimpleLink"
    _hx_is_interface = "False"
    __slots__ = ("f",)
    _hx_fields = ["f"]
    _hx_methods = ["cancel"]
    _hx_interfaces = [tink_core_LinkObject]

    def __init__(self,f):
        self.f = f

    def cancel(self):
        if (self.f is not None):
            self.f()
            self.f = None

tink_core_SimpleLink._hx_class = tink_core_SimpleLink


class tink_core__Callback_LinkPair:
    _hx_class_name = "tink.core._Callback.LinkPair"
    _hx_is_interface = "False"
    __slots__ = ("a", "b", "dissolved")
    _hx_fields = ["a", "b", "dissolved"]
    _hx_methods = ["cancel"]
    _hx_interfaces = [tink_core_LinkObject]

    def __init__(self,a,b):
        self.dissolved = False
        self.a = a
        self.b = b

    def cancel(self):
        if (not self.dissolved):
            self.dissolved = True
            this1 = self.a
            if (this1 is not None):
                this1.cancel()
            this1 = self.b
            if (this1 is not None):
                this1.cancel()
            self.a = None
            self.b = None

tink_core__Callback_LinkPair._hx_class = tink_core__Callback_LinkPair


class tink_core__Callback_ListCell:
    _hx_class_name = "tink.core._Callback.ListCell"
    _hx_is_interface = "False"
    __slots__ = ("cb", "list")
    _hx_fields = ["cb", "list"]
    _hx_methods = ["invoke", "clear", "cancel"]
    _hx_interfaces = [tink_core_LinkObject]

    def __init__(self,cb,_hx_list):
        if (cb is None):
            raise haxe_Exception.thrown("callback expected but null received")
        self.cb = cb
        self.list = _hx_list

    def invoke(self,data):
        if (self.list is not None):
            tink_core__Callback_Callback_Impl_.invoke(self.cb,data)

    def clear(self):
        self.cb = None
        self.list = None

    def cancel(self):
        if (self.list is not None):
            _hx_list = self.list
            self.cb = None
            self.list = None
            def _hx_local_1():
                _hx_list.used = (_hx_list.used - 1)
                return _hx_list.used
            tmp = _hx_local_1()
            if (tmp < ((_hx_list.used >> 1))):
                _hx_list.compact()

tink_core__Callback_ListCell._hx_class = tink_core__Callback_ListCell


class tink_core_CallbackList:
    _hx_class_name = "tink.core.CallbackList"
    _hx_is_interface = "False"
    _hx_fields = ["cells", "used", "queue", "busy"]
    _hx_methods = ["ondrain", "get_length", "release", "add", "invoke", "compact", "resize", "clear"]

    def __init__(self):
        self.busy = False
        self.queue = []
        self.used = 0
        self.cells = []

    def ondrain(self):
        pass

    def get_length(self):
        return self.used

    def release(self):
        self.used = (self.used - 1)
        tmp = self.used
        if (tmp < ((self.used >> 1))):
            self.compact()

    def add(self,cb):
        node = tink_core__Callback_ListCell(cb,self)
        _this = self.cells
        _this.append(node)
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.used
        _hx_local_0.used = (_hx_local_1 + 1)
        _hx_local_1
        return node

    def invoke(self,data,destructive = None):
        if self.busy:
            _this = self.queue
            _g = self.invoke
            data1 = data
            destructive1 = destructive
            def _hx_local_0():
                _g(data1,destructive1)
            tmp = _hx_local_0
            _this.append(tmp)
        else:
            self.busy = True
            length = len(self.cells)
            _g1 = 0
            _g2 = length
            while (_g1 < _g2):
                i = _g1
                _g1 = (_g1 + 1)
                _this = (self.cells[i] if i >= 0 and i < len(self.cells) else None)
                if (_this.list is not None):
                    tink_core__Callback_Callback_Impl_.invoke(_this.cb,data)
            self.busy = False
            if destructive:
                added = (len(self.cells) - length)
                _g1 = 0
                _g2 = length
                while (_g1 < _g2):
                    i = _g1
                    _g1 = (_g1 + 1)
                    _this = (self.cells[i] if i >= 0 and i < len(self.cells) else None)
                    _this.cb = None
                    _this.list = None
                _g1 = 0
                _g2 = added
                while (_g1 < _g2):
                    i = _g1
                    _g1 = (_g1 + 1)
                    python_internal_ArrayImpl._set(self.cells, i, python_internal_ArrayImpl._get(self.cells, (length + i)))
                self.resize(added)
            elif (self.used < len(self.cells)):
                self.compact()
            if (len(self.queue) > 0):
                _this = self.queue
                ((None if ((len(_this) == 0)) else _this.pop(0)))()

    def compact(self):
        if self.busy:
            return
        elif (self.used == 0):
            self.resize(0)
            self.ondrain()
        else:
            compacted = 0
            _g = 0
            _g1 = len(self.cells)
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                _g2 = (self.cells[i] if i >= 0 and i < len(self.cells) else None)
                _g3 = _g2.list
                if (_g2.cb is not None):
                    v = _g2
                    if (compacted != i):
                        python_internal_ArrayImpl._set(self.cells, compacted, v)
                    compacted = (compacted + 1)
                    tmp = compacted
                    if (tmp == self.used):
                        break
            self.resize(self.used)

    def resize(self,length):
        _this = self.cells
        l = len(_this)
        if (l < length):
            idx = (length - 1)
            v = None
            l1 = len(_this)
            while (l1 < idx):
                _this.append(None)
                l1 = (l1 + 1)
            if (l1 == idx):
                _this.append(v)
            else:
                _this[idx] = v
        elif (l > length):
            pos = length
            _hx_len = (l - length)
            if (pos < 0):
                pos = (len(_this) + pos)
            if (pos < 0):
                pos = 0
            res = _this[pos:(pos + _hx_len)]
            del _this[pos:(pos + _hx_len)]

    def clear(self):
        if self.busy:
            _this = self.queue
            _this.append(self.clear)
        _g = 0
        _g1 = self.cells
        while (_g < len(_g1)):
            cell = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            cell.cb = None
            cell.list = None
        self.resize(0)

tink_core_CallbackList._hx_class = tink_core_CallbackList


class tink_core_TypedError:
    _hx_class_name = "tink.core.TypedError"
    _hx_is_interface = "False"
    __slots__ = ("message", "code", "data", "pos", "callStack", "exceptionStack", "isTinkError")
    _hx_fields = ["message", "code", "data", "pos", "callStack", "exceptionStack", "isTinkError"]
    _hx_methods = ["printPos", "toString", "throwSelf"]
    _hx_statics = ["withData", "typed", "asError", "catchExceptions", "reporter", "rethrow", "tryFinally"]

    def __init__(self,code = None,message = None,pos = None):
        if (code is None):
            code = 500
        self.data = None
        self.isTinkError = True
        self.code = code
        self.message = message
        self.pos = pos
        self.exceptionStack = []
        self.callStack = []

    def printPos(self):
        return ((((HxOverrides.stringOrNull(self.pos.className) + ".") + HxOverrides.stringOrNull(self.pos.methodName)) + ":") + Std.string(self.pos.lineNumber))

    def toString(self):
        ret = ((("Error#" + Std.string(self.code)) + ": ") + HxOverrides.stringOrNull(self.message))
        if (self.pos is not None):
            ret = (("null" if ret is None else ret) + HxOverrides.stringOrNull(((" @ " + HxOverrides.stringOrNull(self.printPos())))))
        return ret

    def throwSelf(self):
        any = self
        raise haxe_Exception.thrown(any)

    @staticmethod
    def withData(code = None,message = None,data = None,pos = None):
        return tink_core_TypedError.typed(code,message,data,pos)

    @staticmethod
    def typed(code = None,message = None,data = None,pos = None):
        ret = tink_core_TypedError(code,message,pos)
        ret.data = data
        return ret

    @staticmethod
    def asError(v):
        return Std.downcast(v,tink_core_TypedError)

    @staticmethod
    def catchExceptions(f,report = None,pos = None):
        try:
            return tink_core_Outcome.Success(f())
        except BaseException as _g:
            None
            e = haxe_Exception.caught(_g).unwrap()
            _g = tink_core_TypedError.asError(e)
            tmp = None
            if (_g is None):
                tmp = (tink_core_TypedError.withData(None,"Unexpected Error",e,pos) if ((report is None)) else report(e))
            else:
                e = _g
                tmp = e
            return tink_core_Outcome.Failure(tmp)

    @staticmethod
    def reporter(code = None,message = None,pos = None):
        def _hx_local_0(e):
            return tink_core_TypedError.withData(code,message,e,pos)
        return _hx_local_0

    @staticmethod
    def rethrow(any):
        raise haxe_Exception.thrown(any)

    @staticmethod
    def tryFinally(f,cleanup):
        try:
            ret = f()
            cleanup()
            return ret
        except BaseException as _g:
            None
            e = haxe_Exception.caught(_g).unwrap()
            cleanup()
            raise haxe_Exception.thrown(e)

tink_core_TypedError._hx_class = tink_core_TypedError


class tink_core__Error_Stack_Impl_:
    _hx_class_name = "tink.core._Error.Stack_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["toString"]

    @staticmethod
    def toString(this1):
        return "Error stack not available. Compile with -D error_stack."
tink_core__Error_Stack_Impl_._hx_class = tink_core__Error_Stack_Impl_


class tink_core_FutureObject:
    _hx_class_name = "tink.core.FutureObject"
    _hx_is_interface = "True"
    __slots__ = ()
    _hx_methods = ["map", "flatMap", "handle", "gather", "eager"]
tink_core_FutureObject._hx_class = tink_core_FutureObject


class tink_core__Future_NeverFuture:
    _hx_class_name = "tink.core._Future.NeverFuture"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_methods = ["map", "flatMap", "handle", "gather", "eager"]
    _hx_statics = ["inst"]
    _hx_interfaces = [tink_core_FutureObject]

    def __init__(self):
        pass

    def map(self,f):
        return tink_core__Future_NeverFuture.inst

    def flatMap(self,f):
        return tink_core__Future_NeverFuture.inst

    def handle(self,callback):
        return None

    def gather(self):
        return tink_core__Future_NeverFuture.inst

    def eager(self):
        return tink_core__Future_NeverFuture.inst

tink_core__Future_NeverFuture._hx_class = tink_core__Future_NeverFuture

class tink_core_Noise(Enum):
    __slots__ = ()
    _hx_class_name = "tink.core.Noise"
    _hx_constructs = ["Noise"]
tink_core_Noise.Noise = tink_core_Noise("Noise", 0, ())
tink_core_Noise._hx_class = tink_core_Noise


class tink_core__Lazy_LazyObject:
    _hx_class_name = "tink.core._Lazy.LazyObject"
    _hx_is_interface = "True"
    __slots__ = ()
    _hx_methods = ["get", "map", "flatMap"]
tink_core__Lazy_LazyObject._hx_class = tink_core__Lazy_LazyObject


class tink_core__Lazy_LazyConst:
    _hx_class_name = "tink.core._Lazy.LazyConst"
    _hx_is_interface = "False"
    __slots__ = ("value",)
    _hx_fields = ["value"]
    _hx_methods = ["get", "map", "flatMap"]
    _hx_interfaces = [tink_core__Lazy_LazyObject]

    def __init__(self,value):
        self.value = value

    def get(self):
        return self.value

    def map(self,f):
        _gthis = self
        def _hx_local_1():
            def _hx_local_0():
                return f(_gthis.value)
            return tink_core__Lazy_LazyFunc(_hx_local_0)
        return _hx_local_1()

    def flatMap(self,f):
        _gthis = self
        def _hx_local_1():
            def _hx_local_0():
                return f(_gthis.value).get()
            return tink_core__Lazy_LazyFunc(_hx_local_0)
        return _hx_local_1()

tink_core__Lazy_LazyConst._hx_class = tink_core__Lazy_LazyConst


class tink_core__Future_SyncFuture:
    _hx_class_name = "tink.core._Future.SyncFuture"
    _hx_is_interface = "False"
    __slots__ = ("value",)
    _hx_fields = ["value"]
    _hx_methods = ["map", "flatMap", "handle", "eager", "gather"]
    _hx_interfaces = [tink_core_FutureObject]

    def __init__(self,value):
        self.value = value

    def map(self,f):
        return tink_core__Future_SyncFuture(self.value.map(f))

    def flatMap(self,f):
        _gthis = self
        def _hx_local_1():
            def _hx_local_0(_hx_yield):
                return f(_gthis.value.get()).handle(_hx_yield)
            return tink_core__Future_SuspendableFuture(_hx_local_0)
        return _hx_local_1()

    def handle(self,cb):
        tink_core__Callback_Callback_Impl_.invoke(cb,self.value.get())
        return None

    def eager(self):
        return self

    def gather(self):
        return self

tink_core__Future_SyncFuture._hx_class = tink_core__Future_SyncFuture


class tink_core__Future_Future_Impl_:
    _hx_class_name = "tink.core._Future.Future_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["NULL", "NOISE", "NEVER", "_new", "first", "map", "flatMap", "next", "merge", "flatten", "ofAny", "asPromise", "ofMany", "fromMany", "lazy", "sync", "isFuture", "make", "or", "either", "and", "_tryFailingFlatMap", "_tryFlatMap", "_tryFailingMap", "_tryMap", "_flatMap", "_map", "trigger", "delay"]

    @staticmethod
    def _new(f):
        this1 = tink_core__Future_SuspendableFuture(f)
        return this1

    @staticmethod
    def first(this1,other):
        ret = tink_core_FutureTrigger()
        l1 = this1.handle(ret.trigger)
        l2 = other.handle(ret.trigger)
        ret1 = ret
        if (l1 is not None):
            this1 = l1
            def _hx_local_0(_):
                this1.cancel()
            ret1.handle(_hx_local_0)
        if (l2 is not None):
            this2 = l2
            def _hx_local_1(_):
                this2.cancel()
            ret1.handle(_hx_local_1)
        return ret1

    @staticmethod
    def map(this1,f,gather = None):
        if (gather is None):
            gather = True
        ret = this1.map(f)
        if gather:
            return ret.gather()
        else:
            return ret

    @staticmethod
    def flatMap(this1,next,gather = None):
        if (gather is None):
            gather = True
        ret = this1.flatMap(next)
        if gather:
            return ret.gather()
        else:
            return ret

    @staticmethod
    def next(this1,n):
        def _hx_local_1():
            def _hx_local_0(v):
                return n(v)
            return this1.flatMap(_hx_local_0)
        return _hx_local_1()

    @staticmethod
    def merge(this1,other,merger,gather = None):
        if (gather is None):
            gather = True
        gather1 = gather
        if (gather1 is None):
            gather1 = True
        def _hx_local_1(t):
            gather = False
            if (gather is None):
                gather = True
            def _hx_local_0(a):
                return merger(t,a)
            ret = other.map(_hx_local_0)
            if gather:
                return ret.gather()
            else:
                return ret
        ret = this1.flatMap(_hx_local_1)
        if gather1:
            return ret.gather()
        else:
            return ret

    @staticmethod
    def flatten(f):
        def _hx_local_3():
            def _hx_local_2(_hx_yield):
                inner = None
                def _hx_local_0(second):
                    nonlocal inner
                    inner = second.handle(_hx_yield)
                outer = f.handle(_hx_local_0)
                def _hx_local_1():
                    if (inner is not None):
                        inner.cancel()
                this1 = tink_core_SimpleLink(_hx_local_1)
                return tink_core__Callback_LinkPair(outer,this1)
            return tink_core__Future_SuspendableFuture(_hx_local_2)
        return _hx_local_3()

    @staticmethod
    def ofAny(v):
        return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(v))

    @staticmethod
    def asPromise(s):
        return s

    @staticmethod
    def ofMany(futures,gather = None):
        if (gather is None):
            gather = True
        ret = tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst([]))
        _g = 0
        while (_g < len(futures)):
            f = [(futures[_g] if _g >= 0 and _g < len(futures) else None)]
            _g = (_g + 1)
            gather1 = False
            if (gather1 is None):
                gather1 = True
            def _hx_local_4(f):
                def _hx_local_1(results):
                    gather = False
                    if (gather is None):
                        gather = True
                    def _hx_local_3():
                        def _hx_local_2(result):
                            return (results + [result])
                        return _hx_local_2
                    ret = (f[0] if 0 < len(f) else None).map(_hx_local_3())
                    if gather:
                        return ret.gather()
                    else:
                        return ret
                return _hx_local_1
            ret1 = ret.flatMap(_hx_local_4(f))
            ret = (ret1.gather() if gather1 else ret1)
        if gather:
            return ret.gather()
        else:
            return ret

    @staticmethod
    def fromMany(futures):
        return tink_core__Future_Future_Impl_.ofMany(futures)

    @staticmethod
    def lazy(l):
        return tink_core__Future_SyncFuture(l)

    @staticmethod
    def sync(v):
        return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(v))

    @staticmethod
    def isFuture(maybeFuture):
        return Std.isOfType(maybeFuture,tink_core_FutureObject)

    @staticmethod
    def make(f,lazy = None):
        if (lazy is None):
            lazy = False
        if lazy:
            def _hx_local_1():
                def _hx_local_0(_hx_yield):
                    f(_hx_yield)
                    return None
                return tink_core__Future_SuspendableFuture(_hx_local_0)
            return _hx_local_1()
        else:
            op = tink_core_FutureTrigger()
            wrapped = f
            tink_core__Callback_Callback_Impl_.invoke(wrapped,op.trigger)
            return op

    @staticmethod
    def _hx_or(a,b):
        return tink_core__Future_Future_Impl_.first(a,b)

    @staticmethod
    def either(a,b):
        gather = False
        if (gather is None):
            gather = True
        ret = a.map(haxe_ds_Either.Left)
        tmp = (ret.gather() if gather else ret)
        gather = False
        if (gather is None):
            gather = True
        ret = b.map(haxe_ds_Either.Right)
        return tink_core__Future_Future_Impl_.first(tmp,(ret.gather() if gather else ret))

    @staticmethod
    def _hx_and(a,b):
        def _hx_local_1():
            def _hx_local_0(a,b):
                this1 = tink_core_MPair(a,b)
                return this1
            return tink_core__Future_Future_Impl_.merge(a,b,_hx_local_0)
        return _hx_local_1()

    @staticmethod
    def _tryFailingFlatMap(f,_hx_map):
        def _hx_local_0(o):
            ret = o.index
            if (ret == 0):
                d = o.params[0]
                return _hx_map(d)
            elif (ret == 1):
                f = o.params[0]
                return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(tink_core_Outcome.Failure(f)))
            else:
                pass
        ret = f.flatMap(_hx_local_0)
        return ret.gather()

    @staticmethod
    def _tryFlatMap(f,_hx_map):
        def _hx_local_0(o):
            ret = o.index
            if (ret == 0):
                d = o.params[0]
                ret = _hx_map(d).map(tink_core_Outcome.Success)
                return ret.gather()
            elif (ret == 1):
                f = o.params[0]
                return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(tink_core_Outcome.Failure(f)))
            else:
                pass
        ret = f.flatMap(_hx_local_0)
        return ret.gather()

    @staticmethod
    def _tryFailingMap(f,_hx_map):
        def _hx_local_0(o):
            return tink_core_OutcomeTools.flatMap(o,tink_core__Outcome_OutcomeMapper_Impl_.withSameError(_hx_map))
        ret = f.map(_hx_local_0)
        return ret.gather()

    @staticmethod
    def _tryMap(f,_hx_map):
        def _hx_local_0(o):
            return tink_core_OutcomeTools.map(o,_hx_map)
        ret = f.map(_hx_local_0)
        return ret.gather()

    @staticmethod
    def _flatMap(f,_hx_map):
        ret = f.flatMap(_hx_map)
        return ret.gather()

    @staticmethod
    def _map(f,_hx_map):
        ret = f.map(_hx_map)
        return ret.gather()

    @staticmethod
    def trigger():
        return tink_core_FutureTrigger()

    @staticmethod
    def delay(ms,value):
        def _hx_local_2():
            def _hx_local_1(cb):
                def _hx_local_0():
                    cb(value.get())
                haxe_Timer.delay(_hx_local_0,ms)
            return tink_core__Future_Future_Impl_.make(_hx_local_1)
        return _hx_local_2()
tink_core__Future_Future_Impl_._hx_class = tink_core__Future_Future_Impl_


class tink_core_FutureTrigger:
    _hx_class_name = "tink.core.FutureTrigger"
    _hx_is_interface = "False"
    __slots__ = ("result", "list")
    _hx_fields = ["result", "list"]
    _hx_methods = ["handle", "map", "flatMap", "gather", "eager", "asFuture", "trigger"]
    _hx_statics = ["gatherFuture"]
    _hx_interfaces = [tink_core_FutureObject]

    def __init__(self):
        self.result = None
        self.list = tink_core_CallbackList()

    def handle(self,callback):
        _g = self.list
        if (_g is None):
            tink_core__Callback_Callback_Impl_.invoke(callback,self.result)
            return None
        else:
            v = _g
            node = tink_core__Callback_ListCell(callback,v)
            _this = v.cells
            _this.append(node)
            v.used = (v.used + 1)
            return node

    def map(self,f):
        _g = self.list
        if (_g is None):
            return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(f(self.result)))
        else:
            v = _g
            ret = tink_core_FutureTrigger()
            _this = self.list
            def _hx_local_0(v):
                ret.trigger(f(v))
            node = tink_core__Callback_ListCell(_hx_local_0,_this)
            _this1 = _this.cells
            _this1.append(node)
            _this.used = (_this.used + 1)
            return ret

    def flatMap(self,f):
        _g = self.list
        if (_g is None):
            return f(self.result)
        else:
            v = _g
            ret = tink_core_FutureTrigger()
            _this = self.list
            def _hx_local_0(v):
                f(v).handle(ret.trigger)
            node = tink_core__Callback_ListCell(_hx_local_0,_this)
            _this1 = _this.cells
            _this1.append(node)
            _this.used = (_this.used + 1)
            return ret

    def gather(self):
        return self

    def eager(self):
        return self

    def asFuture(self):
        return self

    def trigger(self,result):
        if (self.list is None):
            return False
        else:
            _hx_list = self.list
            self.list = None
            self.result = result
            _hx_list.invoke(result,True)
            return True

    @staticmethod
    def gatherFuture(f):
        def _hx_local_1():
            def _hx_local_0(_hx_yield):
                return f.handle(_hx_yield)
            return tink_core__Future_SuspendableFuture(_hx_local_0)
        return _hx_local_1()

tink_core_FutureTrigger._hx_class = tink_core_FutureTrigger


class tink_core__Future_SuspendableFuture:
    _hx_class_name = "tink.core._Future.SuspendableFuture"
    _hx_is_interface = "False"
    __slots__ = ("callbacks", "result", "suspended", "link", "wakeup")
    _hx_fields = ["callbacks", "result", "suspended", "link", "wakeup"]
    _hx_methods = ["trigger", "handle", "map", "flatMap", "gather", "eager"]
    _hx_interfaces = [tink_core_FutureObject]

    def __init__(self,wakeup):
        self.wakeup = None
        self.link = None
        self.result = None
        self.callbacks = None
        self.suspended = True
        _gthis = self
        self.wakeup = wakeup
        self.callbacks = tink_core_CallbackList()
        def _hx_local_0():
            if (_gthis.callbacks is not None):
                _gthis.suspended = True
                this1 = _gthis.link
                if (this1 is not None):
                    this1.cancel()
                _gthis.link = None
        self.callbacks.ondrain = _hx_local_0

    def trigger(self,value):
        _g = self.callbacks
        if (_g is not None):
            _hx_list = _g
            self.callbacks = None
            self.suspended = False
            self.result = value
            self.link = None
            self.wakeup = None
            _hx_list.invoke(value,True)

    def handle(self,callback):
        _g = self.callbacks
        if (_g is None):
            tink_core__Callback_Callback_Impl_.invoke(callback,self.result)
            return None
        else:
            v = _g
            _this = self.callbacks
            node = tink_core__Callback_ListCell(callback,_this)
            _this1 = _this.cells
            _this1.append(node)
            _this.used = (_this.used + 1)
            ret = node
            if self.suspended:
                self.suspended = False
                self.link = self.wakeup(self.trigger)
            return ret

    def map(self,f):
        _gthis = self
        def _hx_local_3():
            def _hx_local_2(_hx_yield):
                def _hx_local_1():
                    def _hx_local_0(res):
                        _hx_yield(f(res))
                    return _gthis.handle(_hx_local_0)
                return _hx_local_1()
            return tink_core__Future_SuspendableFuture(_hx_local_2)
        return _hx_local_3()

    def flatMap(self,f):
        return tink_core__Future_Future_Impl_.flatten(self.map(f))

    def gather(self):
        return self

    def eager(self):
        def _hx_local_0():
            pass
        self.handle(tink_core__Callback_Callback_Impl_.fromNiladic(_hx_local_0))
        return self

tink_core__Future_SuspendableFuture._hx_class = tink_core__Future_SuspendableFuture


class tink_core__Lazy_Lazy_Impl_:
    _hx_class_name = "tink.core._Lazy.Lazy_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["NULL", "get", "ofFunc", "map", "flatMap", "ofConst"]

    @staticmethod
    def get(this1):
        return this1.get()

    @staticmethod
    def ofFunc(f):
        return tink_core__Lazy_LazyFunc(f)

    @staticmethod
    def map(this1,f):
        return this1.map(f)

    @staticmethod
    def flatMap(this1,f):
        return this1.flatMap(f)

    @staticmethod
    def ofConst(c):
        return tink_core__Lazy_LazyConst(c)
tink_core__Lazy_Lazy_Impl_._hx_class = tink_core__Lazy_Lazy_Impl_


class tink_core__Lazy_LazyFunc:
    _hx_class_name = "tink.core._Lazy.LazyFunc"
    _hx_is_interface = "False"
    __slots__ = ("f", "result")
    _hx_fields = ["f", "result"]
    _hx_methods = ["get", "map", "flatMap"]
    _hx_interfaces = [tink_core__Lazy_LazyObject]

    def __init__(self,f):
        self.result = None
        self.f = f

    def get(self):
        if (self.f is not None):
            self.result = self.f()
            self.f = None
        return self.result

    def map(self,f):
        _gthis = self
        def _hx_local_1():
            def _hx_local_0():
                return f(_gthis.get())
            return tink_core__Lazy_LazyFunc(_hx_local_0)
        return _hx_local_1()

    def flatMap(self,f):
        _gthis = self
        def _hx_local_1():
            def _hx_local_0():
                return f(_gthis.get()).get()
            return tink_core__Lazy_LazyFunc(_hx_local_0)
        return _hx_local_1()

tink_core__Lazy_LazyFunc._hx_class = tink_core__Lazy_LazyFunc


class tink_core_NamedWith:
    _hx_class_name = "tink.core.NamedWith"
    _hx_is_interface = "False"
    __slots__ = ("name", "value")
    _hx_fields = ["name", "value"]

    def __init__(self,name,value):
        self.name = name
        self.value = value

tink_core_NamedWith._hx_class = tink_core_NamedWith


class tink_core_OptionTools:
    _hx_class_name = "tink.core.OptionTools"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["force", "or", "orNull", "filter", "satisfies", "equals", "map", "flatMap", "iterator", "toArray"]

    @staticmethod
    def force(o,pos = None):
        if (o.index == 0):
            v = o.params[0]
            return v
        else:
            raise haxe_Exception.thrown(tink_core_TypedError(404,"Some value expected but none found",pos))

    @staticmethod
    def _hx_or(o,l):
        if (o.index == 0):
            v = o.params[0]
            return v
        else:
            return l.get()

    @staticmethod
    def orNull(o):
        if (o.index == 0):
            v = o.params[0]
            return v
        else:
            return None

    @staticmethod
    def filter(o,f):
        if (o.index == 0):
            if (f(o.params[0]) == False):
                return haxe_ds_Option._hx_None
            else:
                return o
        else:
            return o

    @staticmethod
    def satisfies(o,f):
        if (o.index == 0):
            v = o.params[0]
            return f(v)
        else:
            return False

    @staticmethod
    def equals(o,v):
        if (o.index == 0):
            v1 = o.params[0]
            return HxOverrides.eq(v1,v)
        else:
            return False

    @staticmethod
    def map(o,f):
        if (o.index == 0):
            v = o.params[0]
            return haxe_ds_Option.Some(f(v))
        else:
            return haxe_ds_Option._hx_None

    @staticmethod
    def flatMap(o,f):
        if (o.index == 0):
            v = o.params[0]
            return f(v)
        else:
            return haxe_ds_Option._hx_None

    @staticmethod
    def iterator(o):
        return tink_core_OptionIter(o)

    @staticmethod
    def toArray(o):
        if (o.index == 0):
            v = o.params[0]
            return [v]
        else:
            return []
tink_core_OptionTools._hx_class = tink_core_OptionTools


class tink_core_OptionIter:
    _hx_class_name = "tink.core.OptionIter"
    _hx_is_interface = "False"
    __slots__ = ("value", "alive")
    _hx_fields = ["value", "alive"]
    _hx_methods = ["hasNext", "next"]

    def __init__(self,o):
        self.value = None
        self.alive = True
        if (o.index == 0):
            v = o.params[0]
            self.value = v
        else:
            self.alive = False

    def hasNext(self):
        return self.alive

    def next(self):
        self.alive = False
        return self.value

tink_core_OptionIter._hx_class = tink_core_OptionIter

class tink_core_Outcome(Enum):
    __slots__ = ()
    _hx_class_name = "tink.core.Outcome"
    _hx_constructs = ["Success", "Failure"]

    @staticmethod
    def Success(data):
        return tink_core_Outcome("Success", 0, (data,))

    @staticmethod
    def Failure(failure):
        return tink_core_Outcome("Failure", 1, (failure,))
tink_core_Outcome._hx_class = tink_core_Outcome


class tink_core_OutcomeTools:
    _hx_class_name = "tink.core.OutcomeTools"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["sure", "toOption", "toOutcome", "orNull", "orUse", "orTry", "equals", "map", "isSuccess", "flatMap", "swap", "next", "attempt", "flatten"]

    @staticmethod
    def sure(outcome):
        tmp = outcome.index
        if (tmp == 0):
            data = outcome.params[0]
            return data
        elif (tmp == 1):
            failure = outcome.params[0]
            _g = tink_core_TypedError.asError(failure)
            if (_g is None):
                raise haxe_Exception.thrown(failure)
            else:
                e = _g
                return e.throwSelf()
        else:
            pass

    @staticmethod
    def toOption(outcome):
        tmp = outcome.index
        if (tmp == 0):
            data = outcome.params[0]
            return haxe_ds_Option.Some(data)
        elif (tmp == 1):
            _g = outcome.params[0]
            return haxe_ds_Option._hx_None
        else:
            pass

    @staticmethod
    def toOutcome(option,pos = None):
        tmp = option.index
        if (tmp == 0):
            value = option.params[0]
            return tink_core_Outcome.Success(value)
        elif (tmp == 1):
            return tink_core_Outcome.Failure(tink_core_TypedError(404,((("Some value expected but none found in " + HxOverrides.stringOrNull(pos.fileName)) + "@line ") + Std.string(pos.lineNumber)),_hx_AnonObject({'fileName': "tink/core/Outcome.hx", 'lineNumber': 48, 'className': "tink.core.OutcomeTools", 'methodName': "toOutcome"})))
        else:
            pass

    @staticmethod
    def orNull(outcome):
        tmp = outcome.index
        if (tmp == 0):
            data = outcome.params[0]
            return data
        elif (tmp == 1):
            _g = outcome.params[0]
            return None
        else:
            pass

    @staticmethod
    def orUse(outcome,fallback):
        tmp = outcome.index
        if (tmp == 0):
            data = outcome.params[0]
            return data
        elif (tmp == 1):
            _g = outcome.params[0]
            return fallback.get()
        else:
            pass

    @staticmethod
    def orTry(outcome,fallback):
        tmp = outcome.index
        if (tmp == 0):
            _g = outcome.params[0]
            return outcome
        elif (tmp == 1):
            _g = outcome.params[0]
            return fallback.get()
        else:
            pass

    @staticmethod
    def equals(outcome,to):
        tmp = outcome.index
        if (tmp == 0):
            data = outcome.params[0]
            return HxOverrides.eq(data,to)
        elif (tmp == 1):
            _g = outcome.params[0]
            return False
        else:
            pass

    @staticmethod
    def map(outcome,transform):
        tmp = outcome.index
        if (tmp == 0):
            a = outcome.params[0]
            return tink_core_Outcome.Success(transform(a))
        elif (tmp == 1):
            f = outcome.params[0]
            return tink_core_Outcome.Failure(f)
        else:
            pass

    @staticmethod
    def isSuccess(outcome):
        if (outcome.index == 0):
            _g = outcome.params[0]
            return True
        else:
            return False

    @staticmethod
    def flatMap(o,mapper):
        return tink_core__Outcome_OutcomeMapper_Impl_.apply(mapper,o)

    @staticmethod
    def swap(outcome,v):
        tmp = outcome.index
        if (tmp == 0):
            a = outcome.params[0]
            return tink_core_Outcome.Success(v)
        elif (tmp == 1):
            f = outcome.params[0]
            return tink_core_Outcome.Failure(f)
        else:
            pass

    @staticmethod
    def next(outcome,f):
        tmp = outcome.index
        if (tmp == 0):
            v = outcome.params[0]
            return f(v)
        elif (tmp == 1):
            e = outcome.params[0]
            return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(tink_core_Outcome.Failure(e)))
        else:
            pass

    @staticmethod
    def attempt(f,report):
        try:
            return tink_core_Outcome.Success(f())
        except BaseException as _g:
            None
            e = haxe_Exception.caught(_g).unwrap()
            return tink_core_Outcome.Failure(report(e))

    @staticmethod
    def flatten(o):
        tmp = o.index
        if (tmp == 0):
            _g = o.params[0]
            tmp = _g.index
            if (tmp == 0):
                d = _g.params[0]
                return tink_core_Outcome.Success(d)
            elif (tmp == 1):
                f = _g.params[0]
                return tink_core_Outcome.Failure(f)
            else:
                pass
        elif (tmp == 1):
            f = o.params[0]
            return tink_core_Outcome.Failure(f)
        else:
            pass
tink_core_OutcomeTools._hx_class = tink_core_OutcomeTools


class tink_core__Outcome_OutcomeMapper_Impl_:
    _hx_class_name = "tink.core._Outcome.OutcomeMapper_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["_new", "apply", "withSameError", "withEitherError"]

    @staticmethod
    def _new(f):
        this1 = _hx_AnonObject({'f': f})
        return this1

    @staticmethod
    def apply(this1,o):
        return this1.f(o)

    @staticmethod
    def withSameError(f):
        def _hx_local_1():
            def _hx_local_0(o):
                tmp = o.index
                if (tmp == 0):
                    d = o.params[0]
                    return f(d)
                elif (tmp == 1):
                    f1 = o.params[0]
                    return tink_core_Outcome.Failure(f1)
                else:
                    pass
            return tink_core__Outcome_OutcomeMapper_Impl_._new(_hx_local_0)
        return _hx_local_1()

    @staticmethod
    def withEitherError(f):
        def _hx_local_1():
            def _hx_local_0(o):
                tmp = o.index
                if (tmp == 0):
                    d = o.params[0]
                    _g = f(d)
                    tmp = _g.index
                    if (tmp == 0):
                        d = _g.params[0]
                        return tink_core_Outcome.Success(d)
                    elif (tmp == 1):
                        f1 = _g.params[0]
                        return tink_core_Outcome.Failure(haxe_ds_Either.Right(f1))
                    else:
                        pass
                elif (tmp == 1):
                    f1 = o.params[0]
                    return tink_core_Outcome.Failure(haxe_ds_Either.Left(f1))
                else:
                    pass
            return tink_core__Outcome_OutcomeMapper_Impl_._new(_hx_local_0)
        return _hx_local_1()
tink_core__Outcome_OutcomeMapper_Impl_._hx_class = tink_core__Outcome_OutcomeMapper_Impl_


class tink_core__Pair_Pair_Impl_:
    _hx_class_name = "tink.core._Pair.Pair_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["_new", "get_a", "get_b", "toBool", "isNil", "nil"]
    a = None
    b = None

    @staticmethod
    def _new(a,b):
        this1 = tink_core_MPair(a,b)
        return this1

    @staticmethod
    def get_a(this1):
        return this1.a

    @staticmethod
    def get_b(this1):
        return this1.b

    @staticmethod
    def toBool(this1):
        return (this1 is not None)

    @staticmethod
    def isNil(this1):
        return (this1 is None)

    @staticmethod
    def nil():
        return None
tink_core__Pair_Pair_Impl_._hx_class = tink_core__Pair_Pair_Impl_


class tink_core_MPair:
    _hx_class_name = "tink.core.MPair"
    _hx_is_interface = "False"
    __slots__ = ("a", "b")
    _hx_fields = ["a", "b"]

    def __init__(self,a,b):
        self.a = a
        self.b = b

tink_core_MPair._hx_class = tink_core_MPair


class tink_core__Progress_Progress_Impl_:
    _hx_class_name = "tink.core._Progress.Progress_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["INIT", "trigger", "make", "asFuture", "asPromise", "promise", "future", "next"]

    @staticmethod
    def trigger():
        return tink_core_ProgressTrigger()

    @staticmethod
    def make(f):
        value = tink_core_ProgressType.InProgress(tink_core__Progress_Progress_Impl_.INIT)
        signal = tink_core__Signal_Signal_Impl_.trigger()
        def _hx_local_2(cb):
            def _hx_local_0(v,total):
                nonlocal value
                progress = value.index
                if (progress == 0):
                    current = value.params[0]
                    if ((current.a != v) or (not tink_core_TotalTools.eq(current.b,total))):
                        this1 = tink_core_MPair(v,total)
                        pv = this1
                        value = tink_core_ProgressType.InProgress(pv)
                        signal.handlers.invoke(pv)
                elif (progress == 1):
                    _g = value.params[0]
                else:
                    pass
            progress = _hx_local_0
            def _hx_local_1(v):
                nonlocal value
                if (value.index == 1):
                    _g = value.params[0]
                else:
                    value = tink_core_ProgressType.Finished(v)
                    cb(v)
            finish = _hx_local_1
            f(progress,finish)
        future = tink_core__Future_Future_Impl_.make(_hx_local_2)
        return tink_core_CompositeProgress(future,signal)

    @staticmethod
    def asFuture(this1):
        return this1

    @staticmethod
    def asPromise(p):
        return p

    @staticmethod
    def promise(v):
        return tink_core_PromiseProgress(v)

    @staticmethod
    def future(v):
        return tink_core_FutureProgress(v)

    @staticmethod
    def next(this1,f):
        return tink_core__Future_Future_Impl_.next(this1,f)
tink_core__Progress_Progress_Impl_._hx_class = tink_core__Progress_Progress_Impl_


class tink_core_SignalObject:
    _hx_class_name = "tink.core.SignalObject"
    _hx_is_interface = "True"
    __slots__ = ()
    _hx_methods = ["listen"]
tink_core_SignalObject._hx_class = tink_core_SignalObject


class tink_core_ProgressObject:
    _hx_class_name = "tink.core.ProgressObject"
    _hx_is_interface = "True"
    __slots__ = ()
    _hx_interfaces = [tink_core_SignalObject, tink_core_FutureObject]
tink_core_ProgressObject._hx_class = tink_core_ProgressObject


class tink_core_CompositeProgress:
    _hx_class_name = "tink.core.CompositeProgress"
    _hx_is_interface = "False"
    __slots__ = ("future", "signal")
    _hx_fields = ["future", "signal"]
    _hx_methods = ["map", "flatMap", "handle", "listen", "gather", "eager"]
    _hx_interfaces = [tink_core_ProgressObject]

    def __init__(self,future,signal):
        self.future = future
        self.signal = signal

    def map(self,f):
        ret = self.future.map(f)
        return ret.gather()

    def flatMap(self,f):
        ret = self.future.flatMap(f)
        return ret.gather()

    def handle(self,callback):
        return self.future.handle(callback)

    def listen(self,callback):
        return self.signal.listen(callback)

    def gather(self):
        return self.future.gather()

    def eager(self):
        return self.future.eager()

tink_core_CompositeProgress._hx_class = tink_core_CompositeProgress


class tink_core_ProgressTrigger(tink_core_CompositeProgress):
    _hx_class_name = "tink.core.ProgressTrigger"
    _hx_is_interface = "False"
    __slots__ = ("futureTrigger", "signalTrigger", "value")
    _hx_fields = ["futureTrigger", "signalTrigger", "value"]
    _hx_methods = ["progress", "finish", "asProgress"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = tink_core_CompositeProgress


    def __init__(self):
        self.signalTrigger = None
        self.futureTrigger = None
        self.value = tink_core_ProgressType.InProgress(tink_core__Progress_Progress_Impl_.INIT)
        def _hx_local_0():
            self.futureTrigger = tink_core_FutureTrigger()
            return self.futureTrigger
        def _hx_local_1():
            self.signalTrigger = tink_core__Signal_Signal_Impl_.trigger()
            return self.signalTrigger
        super().__init__(_hx_local_0(),_hx_local_1())

    def progress(self,v,total):
        _g = self.value
        tmp = _g.index
        if (tmp == 0):
            current = _g.params[0]
            if ((current.a != v) or (not tink_core_TotalTools.eq(current.b,total))):
                this1 = tink_core_MPair(v,total)
                pv = this1
                self.value = tink_core_ProgressType.InProgress(pv)
                self.signalTrigger.handlers.invoke(pv)
        elif (tmp == 1):
            _g1 = _g.params[0]
        else:
            pass

    def finish(self,v):
        _g = self.value
        if (_g.index == 1):
            _g1 = _g.params[0]
        else:
            self.value = tink_core_ProgressType.Finished(v)
            self.futureTrigger.trigger(v)

    def asProgress(self):
        return self

tink_core_ProgressTrigger._hx_class = tink_core_ProgressTrigger


class tink_core_FutureProgress(tink_core_CompositeProgress):
    _hx_class_name = "tink.core.FutureProgress"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = []
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = tink_core_CompositeProgress


    def __init__(self,future):
        def _hx_local_0(progress):
            return progress
        ret = future.flatMap(_hx_local_0)
        def _hx_local_2(cb):
            def _hx_local_1(progress):
                progress.listen(cb)
            future.handle(_hx_local_1)
        super().__init__(ret.gather(),tink_core__Signal_Signal_Impl_.generate(_hx_local_2))
tink_core_FutureProgress._hx_class = tink_core_FutureProgress


class tink_core_PromiseProgress(tink_core_CompositeProgress):
    _hx_class_name = "tink.core.PromiseProgress"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = []
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = tink_core_CompositeProgress


    def __init__(self,promise):
        def _hx_local_0(o):
            ret = o.index
            if (ret == 0):
                progress = o.params[0]
                return progress.map(tink_core_Outcome.Success)
            elif (ret == 1):
                e = o.params[0]
                return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(tink_core_Outcome.Failure(e)))
            else:
                pass
        ret = promise.flatMap(_hx_local_0)
        def _hx_local_2(cb):
            def _hx_local_1(o):
                tmp = o.index
                if (tmp == 0):
                    progress = o.params[0]
                    progress.listen(cb)
                elif (tmp == 1):
                    e = o.params[0]
                else:
                    pass
            promise.handle(_hx_local_1)
        super().__init__(ret.gather(),tink_core__Signal_Signal_Impl_.generate(_hx_local_2))
tink_core_PromiseProgress._hx_class = tink_core_PromiseProgress


class tink_core__Progress_ProgressValue_Impl_:
    _hx_class_name = "tink.core._Progress.ProgressValue_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["_new", "normalize", "get_value", "get_total"]
    value = None
    total = None

    @staticmethod
    def _new(value,total):
        this1 = tink_core_MPair(value,total)
        this2 = this1
        return this2

    @staticmethod
    def normalize(this1):
        o = this1.b
        if (o.index == 0):
            v = o.params[0]
            return haxe_ds_Option.Some((this1.a / v))
        else:
            return haxe_ds_Option._hx_None

    @staticmethod
    def get_value(this1):
        return this1.a

    @staticmethod
    def get_total(this1):
        return this1.b
tink_core__Progress_ProgressValue_Impl_._hx_class = tink_core__Progress_ProgressValue_Impl_


class tink_core__Progress_UnitInterval_Impl_:
    _hx_class_name = "tink.core._Progress.UnitInterval_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["toPercentageString"]

    @staticmethod
    def toPercentageString(this1,dp):
        m = Math.pow(10,dp)
        v = (Math.floor((((this1 * m) * 100) + 0.5)) / m)
        s = Std.string(v)
        startIndex = None
        _g = (s.find(".") if ((startIndex is None)) else HxString.indexOfImpl(s,".",startIndex))
        if (_g == -1):
            return (((("null" if s is None else s) + ".") + HxOverrides.stringOrNull(StringTools.lpad("","0",dp))) + "%")
        else:
            i = _g
            if ((len(s) - i) > dp):
                return (HxOverrides.stringOrNull(HxString.substr(s,0,((dp + i) + 1))) + "%")
            else:
                i = _g
                return (HxOverrides.stringOrNull(StringTools.rpad(s,"0",((i + dp) + 1))) + "%")
tink_core__Progress_UnitInterval_Impl_._hx_class = tink_core__Progress_UnitInterval_Impl_

class tink_core_ProgressType(Enum):
    __slots__ = ()
    _hx_class_name = "tink.core.ProgressType"
    _hx_constructs = ["InProgress", "Finished"]

    @staticmethod
    def InProgress(v):
        return tink_core_ProgressType("InProgress", 0, (v,))

    @staticmethod
    def Finished(v):
        return tink_core_ProgressType("Finished", 1, (v,))
tink_core_ProgressType._hx_class = tink_core_ProgressType


class tink_core_TotalTools:
    _hx_class_name = "tink.core.TotalTools"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["eq"]

    @staticmethod
    def eq(a,b):
        tmp = a.index
        if (tmp == 0):
            if (b.index == 0):
                t1 = a.params[0]
                t2 = b.params[0]
                return (t1 == t2)
            else:
                return False
        elif (tmp == 1):
            if (b.index == 1):
                return True
            else:
                return False
        else:
            pass
tink_core_TotalTools._hx_class = tink_core_TotalTools


class tink_core__Promise_Promise_Impl_:
    _hx_class_name = "tink.core._Promise.Promise_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["NULL", "NOISE", "NEVER", "_new", "eager", "map", "flatMap", "tryRecover", "recover", "mapError", "handle", "noise", "isSuccess", "next", "swap", "swapError", "merge", "and", "iterate", "retry", "ofSpecific", "ofFuture", "ofOutcome", "ofError", "ofData", "lazy", "inParallel", "inSequence", "cache", "lift", "trigger", "resolve", "reject"]

    @staticmethod
    def _new(f,lazy = None):
        if (lazy is None):
            lazy = False
        def _hx_local_2(cb):
            def _hx_local_0(v):
                cb(tink_core_Outcome.Success(v))
            def _hx_local_1(e):
                cb(tink_core_Outcome.Failure(e))
            f(_hx_local_0,_hx_local_1)
        this1 = tink_core__Future_Future_Impl_.make(_hx_local_2,lazy)
        return this1

    @staticmethod
    def eager(this1):
        return this1.eager()

    @staticmethod
    def map(this1,f):
        ret = this1.map(f)
        return ret.gather()

    @staticmethod
    def flatMap(this1,f):
        ret = this1.flatMap(f)
        return ret.gather()

    @staticmethod
    def tryRecover(this1,f):
        def _hx_local_0(o):
            ret = o.index
            if (ret == 0):
                d = o.params[0]
                return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(o))
            elif (ret == 1):
                e = o.params[0]
                return f(e)
            else:
                pass
        ret = this1.flatMap(_hx_local_0)
        return ret.gather()

    @staticmethod
    def recover(this1,f):
        def _hx_local_0(o):
            ret = o.index
            if (ret == 0):
                d = o.params[0]
                return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(d))
            elif (ret == 1):
                e = o.params[0]
                return f(e)
            else:
                pass
        ret = this1.flatMap(_hx_local_0)
        return ret.gather()

    @staticmethod
    def mapError(this1,f):
        def _hx_local_0(o):
            ret = o.index
            if (ret == 0):
                _g = o.params[0]
                return o
            elif (ret == 1):
                e = o.params[0]
                return tink_core_Outcome.Failure(f(e))
            else:
                pass
        ret = this1.map(_hx_local_0)
        return ret.gather()

    @staticmethod
    def handle(this1,cb):
        return this1.handle(cb)

    @staticmethod
    def noise(this1):
        def _hx_local_1():
            def _hx_local_0(v):
                return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(tink_core_Outcome.Success(tink_core_Noise.Noise)))
            return tink_core__Promise_Promise_Impl_.next(this1,_hx_local_0)
        return _hx_local_1()

    @staticmethod
    def isSuccess(this1):
        def _hx_local_0(o):
            return tink_core_OutcomeTools.isSuccess(o)
        ret = this1.map(_hx_local_0)
        return ret.gather()

    @staticmethod
    def next(this1,f,gather = None):
        if (gather is None):
            gather = True
        gather1 = gather
        if (gather1 is None):
            gather1 = True
        def _hx_local_0(o):
            ret = o.index
            if (ret == 0):
                d = o.params[0]
                return f(d)
            elif (ret == 1):
                f1 = o.params[0]
                return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(tink_core_Outcome.Failure(f1)))
            else:
                pass
        ret = this1.flatMap(_hx_local_0)
        if gather1:
            return ret.gather()
        else:
            return ret

    @staticmethod
    def swap(this1,v):
        def _hx_local_1():
            def _hx_local_0(_):
                return v
            return tink_core__Future_Future_Impl_._tryMap(this1,_hx_local_0)
        return _hx_local_1()

    @staticmethod
    def swapError(this1,e):
        def _hx_local_1():
            def _hx_local_0(_):
                return e
            return tink_core__Promise_Promise_Impl_.mapError(this1,_hx_local_0)
        return _hx_local_1()

    @staticmethod
    def merge(this1,other,merger,gather = None):
        if (gather is None):
            gather = True
        def _hx_local_3():
            def _hx_local_2(t):
                def _hx_local_1():
                    def _hx_local_0(a):
                        return merger(t,a)
                    return tink_core__Promise_Promise_Impl_.next(other,_hx_local_0,False)
                return _hx_local_1()
            return tink_core__Promise_Promise_Impl_.next(this1,_hx_local_2,gather)
        return _hx_local_3()

    @staticmethod
    def _hx_and(a,b):
        def _hx_local_1():
            def _hx_local_0(a,b):
                this1 = tink_core_MPair(a,b)
                return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(tink_core_Outcome.Success(this1)))
            return tink_core__Promise_Promise_Impl_.merge(a,b,_hx_local_0)
        return _hx_local_1()

    @staticmethod
    def iterate(promises,_hx_yield,fallback,lazy = None):
        def _hx_local_4():
            def _hx_local_3(cb):
                _hx_iter = HxOverrides.iterator(promises)
                next = None
                def _hx_local_2():
                    if _hx_iter.hasNext():
                        def _hx_local_1(o):
                            next1 = o.index
                            if (next1 == 0):
                                v = o.params[0]
                                def _hx_local_0(o):
                                    next1 = o.index
                                    if (next1 == 0):
                                        _g = o.params[0]
                                        next1 = _g.index
                                        if (next1 == 0):
                                            ret = _g.params[0]
                                            cb(tink_core_Outcome.Success(ret))
                                        elif (next1 == 1):
                                            next()
                                        else:
                                            pass
                                    elif (next1 == 1):
                                        e = o.params[0]
                                        cb(tink_core_Outcome.Failure(e))
                                    else:
                                        pass
                                _hx_yield(v).handle(_hx_local_0)
                            elif (next1 == 1):
                                e = o.params[0]
                                cb(tink_core_Outcome.Failure(e))
                            else:
                                pass
                        _hx_iter.next().handle(_hx_local_1)
                    else:
                        fallback.handle(cb)
                next = _hx_local_2
                next()
            return tink_core__Future_Future_Impl_.make(_hx_local_3,lazy)
        return _hx_local_4()

    @staticmethod
    def retry(gen,next):
        def _hx_local_0():
            return (python_lib_Timeit.default_timer() * 1000)
        stamp = _hx_local_0
        start = stamp()
        attempt = None
        def _hx_local_5(count):
            def _hx_local_3(error):
                def _hx_local_2():
                    def _hx_local_1(_):
                        return attempt((count + 1))
                    return tink_core__Promise_Promise_Impl_.next(next(_hx_AnonObject({'attempt': count, 'error': error, 'elapsed': (stamp() - start)})),_hx_local_1)
                return _hx_local_2()
            f = _hx_local_3
            def _hx_local_4(o):
                ret = o.index
                if (ret == 0):
                    d = o.params[0]
                    return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(o))
                elif (ret == 1):
                    e = o.params[0]
                    return f(e)
                else:
                    pass
            ret = gen().flatMap(_hx_local_4)
            return ret.gather()
        attempt = _hx_local_5
        return attempt(1)

    @staticmethod
    def ofSpecific(s):
        return s

    @staticmethod
    def ofFuture(f):
        ret = f.map(tink_core_Outcome.Success)
        return ret.gather()

    @staticmethod
    def ofOutcome(o):
        return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(o))

    @staticmethod
    def ofError(e):
        return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(tink_core_Outcome.Failure(e)))

    @staticmethod
    def ofData(d):
        return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(tink_core_Outcome.Success(d)))

    @staticmethod
    def lazy(p):
        def _hx_local_1():
            def _hx_local_0(cb):
                p.get().handle(cb)
            return tink_core__Future_Future_Impl_.make(_hx_local_0,True)
        return _hx_local_1()

    @staticmethod
    def inParallel(a,concurrency = None,lazy = None):
        if (len(a) == 0):
            return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(tink_core_Outcome.Success([])))
        else:
            def _hx_local_11():
                def _hx_local_10(cb):
                    nonlocal concurrency
                    result = []
                    pending = len(a)
                    links = None
                    linkArray = []
                    sync = False
                    i = 0
                    iter_current = None
                    iter_array = None
                    iter_current = 0
                    iter_array = a
                    next = None
                    def _hx_local_0(o):
                        nonlocal sync
                        if (links is None):
                            sync = True
                        elif (links is not None):
                            links.cancel()
                        cb(o)
                    done = _hx_local_0
                    def _hx_local_1(e):
                        nonlocal pending
                        pending = 0
                        done(tink_core_Outcome.Failure(e))
                    fail = _hx_local_1
                    def _hx_local_4(index,value):
                        python_internal_ArrayImpl._set(result, index, value)
                        def _hx_local_3():
                            nonlocal pending
                            pending = (pending - 1)
                            return pending
                        if ((_hx_local_3()) == 0):
                            done(tink_core_Outcome.Success(result))
                        elif ((iter_current < len(iter_array)) and ((pending > 0))):
                            next()
                    _hx_set = _hx_local_4
                    def _hx_local_8():
                        nonlocal i
                        nonlocal iter_current
                        i = (i + 1)
                        index = (i - 1)
                        iter_current = (iter_current + 1)
                        def _hx_local_7(o):
                            x = o.index
                            if (x == 0):
                                v = o.params[0]
                                _hx_set(index,v)
                            elif (x == 1):
                                e = o.params[0]
                                fail(e)
                            else:
                                pass
                        x = python_internal_ArrayImpl._get(iter_array, (iter_current - 1)).handle(_hx_local_7)
                        linkArray.append(x)
                    next = _hx_local_8
                    while True:
                        tmp = None
                        if ((iter_current < len(iter_array)) and ((pending > 0))):
                            if (concurrency is not None):
                                concurrency = (concurrency - 1)
                                tmp = ((concurrency + 1) > 0)
                            else:
                                tmp = True
                        else:
                            tmp = False
                        if (not tmp):
                            break
                        next()
                    links = tink_core__Callback_CallbackLink_Impl_.fromMany(linkArray)
                    if sync:
                        if (links is not None):
                            links.cancel()
                return tink_core__Future_Future_Impl_.make(_hx_local_10,lazy)
            return _hx_local_11()

    @staticmethod
    def inSequence(a):
        loop = None
        def _hx_local_4(index):
            if (index == len(a)):
                return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(tink_core_Outcome.Success([])))
            else:
                def _hx_local_3():
                    def _hx_local_2(head):
                        def _hx_local_1():
                            def _hx_local_0(tail):
                                return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(tink_core_Outcome.Success(([head] + tail))))
                            return tink_core__Promise_Promise_Impl_.next(loop((index + 1)),_hx_local_0)
                        return _hx_local_1()
                    return tink_core__Promise_Promise_Impl_.next((a[index] if index >= 0 and index < len(a) else None),_hx_local_2)
                return _hx_local_3()
        loop = _hx_local_4
        return loop(0)

    @staticmethod
    def cache(gen):
        p = None
        def _hx_local_0():
            nonlocal p
            ret = p
            if (ret is None):
                sync = False
                def _hx_local_2(o):
                    def _hx_local_1(_):
                        nonlocal sync
                        nonlocal p
                        sync = True
                        p = None
                    o.b.handle(_hx_local_1)
                    return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(tink_core_Outcome.Success(o.a)))
                ret = tink_core__Promise_Promise_Impl_.next(gen(),_hx_local_2)
                if (not sync):
                    p = ret
            def _hx_local_3(o):
                nonlocal p
                if (not tink_core_OutcomeTools.isSuccess(o)):
                    p = None
                return o
            ret1 = ret.map(_hx_local_3)
            return ret1.gather()
        return _hx_local_0

    @staticmethod
    def lift(p):
        return p

    @staticmethod
    def trigger():
        this1 = tink_core_FutureTrigger()
        return this1

    @staticmethod
    def resolve(v):
        return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(tink_core_Outcome.Success(v)))

    @staticmethod
    def reject(e):
        return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(tink_core_Outcome.Failure(e)))
tink_core__Promise_Promise_Impl_._hx_class = tink_core__Promise_Promise_Impl_


class tink_core__Promise_Next_Impl_:
    _hx_class_name = "tink.core._Promise.Next_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["ofSafe", "ofSync", "ofSafeSync", "_chain"]

    @staticmethod
    def ofSafe(f):
        def _hx_local_0(x):
            return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(f(x)))
        return _hx_local_0

    @staticmethod
    def ofSync(f):
        def _hx_local_0(x):
            ret = f(x).map(tink_core_Outcome.Success)
            return ret.gather()
        return _hx_local_0

    @staticmethod
    def ofSafeSync(f):
        def _hx_local_0(x):
            return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(tink_core_Outcome.Success(f(x))))
        return _hx_local_0

    @staticmethod
    def _chain(a,b):
        def _hx_local_0(v):
            return tink_core__Promise_Promise_Impl_.next(a(v),b)
        return _hx_local_0
tink_core__Promise_Next_Impl_._hx_class = tink_core__Promise_Next_Impl_


class tink_core__Promise_Recover_Impl_:
    _hx_class_name = "tink.core._Promise.Recover_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["ofSync"]

    @staticmethod
    def ofSync(f):
        def _hx_local_0(e):
            return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(f(e)))
        return _hx_local_0
tink_core__Promise_Recover_Impl_._hx_class = tink_core__Promise_Recover_Impl_


class tink_core__Promise_Combiner_Impl_:
    _hx_class_name = "tink.core._Promise.Combiner_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["ofSafe", "ofSync", "ofSafeSync"]

    @staticmethod
    def ofSafe(f):
        def _hx_local_0(x1,x2):
            return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(f(x1,x2)))
        return _hx_local_0

    @staticmethod
    def ofSync(f):
        def _hx_local_0(x1,x2):
            ret = f(x1,x2).map(tink_core_Outcome.Success)
            return ret.gather()
        return _hx_local_0

    @staticmethod
    def ofSafeSync(f):
        def _hx_local_0(x1,x2):
            return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(tink_core_Outcome.Success(f(x1,x2))))
        return _hx_local_0
tink_core__Promise_Combiner_Impl_._hx_class = tink_core__Promise_Combiner_Impl_


class tink_core__Promise_PromiseTrigger_Impl_:
    _hx_class_name = "tink.core._Promise.PromiseTrigger_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["_new", "resolve", "reject", "asPromise"]

    @staticmethod
    def _new():
        this1 = tink_core_FutureTrigger()
        return this1

    @staticmethod
    def resolve(this1,v):
        return this1.trigger(tink_core_Outcome.Success(v))

    @staticmethod
    def reject(this1,e):
        return this1.trigger(tink_core_Outcome.Failure(e))

    @staticmethod
    def asPromise(this1):
        return this1
tink_core__Promise_PromiseTrigger_Impl_._hx_class = tink_core__Promise_PromiseTrigger_Impl_


class tink_core__Ref_Ref_Impl_:
    _hx_class_name = "tink.core._Ref.Ref_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["_new", "get_value", "set_value", "toString", "to"]
    value = None

    @staticmethod
    def _new():
        this1 = [None]*1
        this2 = this1
        return this2

    @staticmethod
    def get_value(this1):
        return this1[0]

    @staticmethod
    def set_value(this1,param):
        this1[0] = param
        return param

    @staticmethod
    def toString(this1):
        return (("@[" + Std.string(this1[0])) + "]")

    @staticmethod
    def to(v):
        this1 = [None]*1
        this2 = this1
        ret = this2
        ret[0] = v
        return ret
tink_core__Ref_Ref_Impl_._hx_class = tink_core__Ref_Ref_Impl_


class tink_core__Signal_Signal_Impl_:
    _hx_class_name = "tink.core._Signal.Signal_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["_new", "handle", "map", "flatMap", "filter", "select", "join", "nextTime", "until", "next", "noise", "gather", "generate", "trigger", "create", "ofClassical"]

    @staticmethod
    def _new(f):
        this1 = tink_core__Signal_SimpleSignal(f)
        return this1

    @staticmethod
    def handle(this1,handler):
        return this1.listen(handler)

    @staticmethod
    def map(this1,f,gather = None):
        if (gather is None):
            gather = True
        def _hx_local_2(cb):
            def _hx_local_1():
                def _hx_local_0(result):
                    tink_core__Callback_Callback_Impl_.invoke(cb,f(result))
                return this1.listen(_hx_local_0)
            return _hx_local_1()
        this2 = tink_core__Signal_SimpleSignal(_hx_local_2)
        ret = this2
        if gather:
            return tink_core__Signal_Signal_Impl_.gather(ret)
        else:
            return ret

    @staticmethod
    def flatMap(this1,f,gather = None):
        if (gather is None):
            gather = True
        def _hx_local_2(cb):
            def _hx_local_1():
                def _hx_local_0(result):
                    f(result).handle(cb)
                return this1.listen(_hx_local_0)
            return _hx_local_1()
        this2 = tink_core__Signal_SimpleSignal(_hx_local_2)
        ret = this2
        if gather:
            return tink_core__Signal_Signal_Impl_.gather(ret)
        else:
            return ret

    @staticmethod
    def filter(this1,f,gather = None):
        if (gather is None):
            gather = True
        def _hx_local_2(cb):
            def _hx_local_1():
                def _hx_local_0(result):
                    if f(result):
                        tink_core__Callback_Callback_Impl_.invoke(cb,result)
                return this1.listen(_hx_local_0)
            return _hx_local_1()
        this2 = tink_core__Signal_SimpleSignal(_hx_local_2)
        ret = this2
        if gather:
            return tink_core__Signal_Signal_Impl_.gather(ret)
        else:
            return ret

    @staticmethod
    def select(this1,selector,gather = None):
        if (gather is None):
            gather = True
        def _hx_local_2(cb):
            def _hx_local_1():
                def _hx_local_0(result):
                    _g = selector(result)
                    this1 = _g.index
                    if (this1 == 0):
                        v = _g.params[0]
                        tink_core__Callback_Callback_Impl_.invoke(cb,v)
                    elif (this1 == 1):
                        pass
                    else:
                        pass
                return this1.listen(_hx_local_0)
            return _hx_local_1()
        this2 = tink_core__Signal_SimpleSignal(_hx_local_2)
        ret = this2
        if gather:
            return tink_core__Signal_Signal_Impl_.gather(ret)
        else:
            return ret

    @staticmethod
    def join(this1,other,gather = None):
        if (gather is None):
            gather = True
        def _hx_local_0(cb):
            return tink_core__Callback_LinkPair(this1.listen(cb),other.listen(cb))
        this2 = tink_core__Signal_SimpleSignal(_hx_local_0)
        ret = this2
        if gather:
            return tink_core__Signal_Signal_Impl_.gather(ret)
        else:
            return ret

    @staticmethod
    def nextTime(this1,condition = None):
        ret = tink_core_FutureTrigger()
        link = None
        immediate = False
        def _hx_local_0(v):
            nonlocal immediate
            if ((condition is None) or condition(v)):
                ret.trigger(v)
                if (link is None):
                    immediate = True
                elif (link is not None):
                    link.cancel()
        link = this1.listen(_hx_local_0)
        if immediate:
            if (link is not None):
                link.cancel()
        return ret

    @staticmethod
    def until(this1,end):
        def _hx_local_0(_hx_yield):
            this2 = this1.listen(_hx_yield)
            if (this2 is None):
                return tink_core__Callback_CallbackLink_Impl_.noop
            else:
                return this2.cancel
        ret = tink_core__Signal_Suspendable(_hx_local_0)
        end.handle(tink_core__Callback_Callback_Impl_.fromNiladic(ret.kill))
        return ret

    @staticmethod
    def next(this1,condition = None):
        return tink_core__Signal_Signal_Impl_.nextTime(this1,condition)

    @staticmethod
    def noise(this1):
        def _hx_local_1():
            def _hx_local_0(_):
                return tink_core_Noise.Noise
            return tink_core__Signal_Signal_Impl_.map(this1,_hx_local_0)
        return _hx_local_1()

    @staticmethod
    def gather(this1):
        ret = tink_core__Signal_Signal_Impl_.trigger()
        def _hx_local_0(x):
            ret.handlers.invoke(x)
        this1.listen(_hx_local_0)
        return ret

    @staticmethod
    def generate(generator):
        ret = tink_core__Signal_Signal_Impl_.trigger()
        generator(ret.trigger)
        return ret

    @staticmethod
    def trigger():
        return tink_core_SignalTrigger()

    @staticmethod
    def create(create):
        return tink_core__Signal_Suspendable(create)

    @staticmethod
    def ofClassical(add,remove,gather = None):
        if (gather is None):
            gather = True
        def _hx_local_2(cb):
            def _hx_local_0(a):
                tink_core__Callback_Callback_Impl_.invoke(cb,a)
            f = _hx_local_0
            add(f)
            _g = remove
            a1 = f
            def _hx_local_1():
                _g(a1)
            this1 = tink_core_SimpleLink(_hx_local_1)
            return this1
        this1 = tink_core__Signal_SimpleSignal(_hx_local_2)
        ret = this1
        if gather:
            return tink_core__Signal_Signal_Impl_.gather(ret)
        else:
            return ret
tink_core__Signal_Signal_Impl_._hx_class = tink_core__Signal_Signal_Impl_


class tink_core__Signal_SimpleSignal:
    _hx_class_name = "tink.core._Signal.SimpleSignal"
    _hx_is_interface = "False"
    __slots__ = ("f",)
    _hx_fields = ["f"]
    _hx_methods = ["listen"]
    _hx_interfaces = [tink_core_SignalObject]

    def __init__(self,f):
        self.f = f

    def listen(self,cb):
        return self.f(cb)

tink_core__Signal_SimpleSignal._hx_class = tink_core__Signal_SimpleSignal


class tink_core__Signal_Suspendable:
    _hx_class_name = "tink.core._Signal.Suspendable"
    _hx_is_interface = "False"
    __slots__ = ("trigger", "activate", "suspend", "check", "killed")
    _hx_fields = ["trigger", "activate", "suspend", "check", "killed"]
    _hx_methods = ["kill", "listen"]
    _hx_interfaces = [tink_core_SignalObject]

    def __init__(self,activate):
        self.check = None
        self.suspend = None
        self.killed = False
        self.trigger = tink_core_SignalTrigger()
        self.activate = activate

    def kill(self):
        if (not self.killed):
            self.killed = True
            self.trigger = None

    def listen(self,cb):
        _gthis = self
        if self.killed:
            return None
        if (self.trigger.handlers.used == 0):
            self.suspend = self.activate(self.trigger.trigger)
        _this = self.trigger.handlers
        node = tink_core__Callback_ListCell(cb,_this)
        _this1 = _this.cells
        _this1.append(node)
        _this.used = (_this.used + 1)
        def _hx_local_1():
            if (_gthis.trigger.handlers.used == 0):
                _gthis.suspend()
                _gthis.suspend = None
        this1 = tink_core_SimpleLink(_hx_local_1)
        return tink_core__Callback_LinkPair(node,this1)

tink_core__Signal_Suspendable._hx_class = tink_core__Signal_Suspendable


class tink_core_SignalTrigger:
    _hx_class_name = "tink.core.SignalTrigger"
    _hx_is_interface = "False"
    __slots__ = ("handlers",)
    _hx_fields = ["handlers"]
    _hx_methods = ["trigger", "getLength", "listen", "clear", "asSignal"]
    _hx_interfaces = [tink_core_SignalObject]

    def __init__(self):
        self.handlers = tink_core_CallbackList()

    def trigger(self,event):
        self.handlers.invoke(event)

    def getLength(self):
        return self.handlers.used

    def listen(self,cb):
        _this = self.handlers
        node = tink_core__Callback_ListCell(cb,_this)
        _this1 = _this.cells
        _this1.append(node)
        _this.used = (_this.used + 1)
        return node

    def clear(self):
        self.handlers.clear()

    def asSignal(self):
        return self

tink_core_SignalTrigger._hx_class = tink_core_SignalTrigger


class tink_streams__IdealStream_IdealStream_Impl_:
    _hx_class_name = "tink.streams._IdealStream.IdealStream_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["promiseOfIdealStream", "promiseOfStreamNoise", "collect"]

    @staticmethod
    def promiseOfIdealStream(p):
        return tink_streams__Stream_Stream_Impl_.promise(tink_core__Promise_Promise_Impl_.ofSpecific(p))

    @staticmethod
    def promiseOfStreamNoise(p):
        return tink_streams__Stream_Stream_Impl_.promise(p)

    @staticmethod
    def collect(this1):
        buf = []
        def _hx_local_1(x):
            buf.append(x)
            return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(tink_streams_Handled.Resume))
        def _hx_local_0(c):
            return buf
        ret = this1.forEach(tink_streams__Stream_Handler_Impl_.ofSafe(_hx_local_1)).map(_hx_local_0)
        return ret.gather()
tink_streams__IdealStream_IdealStream_Impl_._hx_class = tink_streams__IdealStream_IdealStream_Impl_


class tink_streams_StreamObject:
    _hx_class_name = "tink.streams.StreamObject"
    _hx_is_interface = "True"
    __slots__ = ()
    _hx_methods = ["get_depleted", "next", "regroup", "map", "filter", "retain", "idealize", "append", "prepend", "blend", "decompose", "forEach", "reduce"]
tink_streams_StreamObject._hx_class = tink_streams_StreamObject


class tink_streams_StreamBase:
    _hx_class_name = "tink.streams.StreamBase"
    _hx_is_interface = "False"
    __slots__ = ("retainCount",)
    _hx_fields = ["retainCount"]
    _hx_methods = ["get_depleted", "retain", "next", "regroup", "map", "filter", "destroy", "append", "prepend", "blend", "decompose", "idealize", "reduce", "forEach"]
    _hx_interfaces = [tink_streams_StreamObject]

    def __init__(self):
        self.retainCount = 0

    def get_depleted(self):
        return False

    def retain(self):
        _gthis = self
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.retainCount
        _hx_local_0.retainCount = (_hx_local_1 + 1)
        _hx_local_1
        retained = True
        def _hx_local_2():
            nonlocal retained
            if retained:
                retained = False
                def _hx_local_4():
                    _gthis.retainCount = (_gthis.retainCount - 1)
                    return _gthis.retainCount
                tmp = (_hx_local_4() == 0)
                if tmp:
                    _gthis.destroy()
        return _hx_local_2

    def next(self):
        raise haxe_Exception.thrown("not implemented")

    def regroup(self,f):
        return tink_streams__Stream_RegroupStream(self,f)

    def map(self,f):
        return self.regroup(f)

    def filter(self,f):
        return self.regroup(f)

    def destroy(self):
        pass

    def append(self,other):
        if self.get_depleted():
            return other
        else:
            return tink_streams__Stream_CompoundStream.of([self, other])

    def prepend(self,other):
        if self.get_depleted():
            return other
        else:
            return tink_streams__Stream_CompoundStream.of([other, self])

    def blend(self,other):
        if self.get_depleted():
            return other
        else:
            return tink_streams_BlendStream(self,other)

    def decompose(self,into):
        if (not self.get_depleted()):
            into.append(self)

    def idealize(self,rescue):
        if self.get_depleted():
            return tink_streams_Empty.inst
        else:
            return tink_streams_IdealizeStream(self,rescue)

    def reduce(self,initial,reducer):
        _gthis = self
        def _hx_local_4():
            def _hx_local_3(cb):
                def _hx_local_2(item):
                    def _hx_local_1(o):
                        nonlocal initial
                        ret = o.index
                        if (ret == 0):
                            v = o.params[0]
                            initial = v
                            return tink_streams_Handled.Resume
                        elif (ret == 1):
                            e = o.params[0]
                            return tink_streams_Handled.Clog(e)
                        else:
                            pass
                    ret = reducer(initial,item).map(_hx_local_1)
                    return ret.gather()
                def _hx_local_0(c):
                    tmp = c.index
                    if (tmp == 0):
                        _g = c.params[0]
                        raise haxe_Exception.thrown("assert")
                    elif (tmp == 1):
                        rest = c.params[1]
                        e = c.params[0]
                        cb(tink_streams_Reduction.Crashed(e,rest))
                    elif (tmp == 2):
                        e = c.params[0]
                        cb(tink_streams_Reduction.Failed(e))
                    elif (tmp == 3):
                        cb(tink_streams_Reduction.Reduced(initial))
                    else:
                        pass
                _gthis.forEach(tink_streams__Stream_Handler_Impl_.ofUnknown(_hx_local_2)).handle(_hx_local_0)
            return tink_core__Future_Future_Impl_.make(_hx_local_3,True)
        return _hx_local_4()

    def forEach(self,handler):
        raise haxe_Exception.thrown("not implemented")

tink_streams_StreamBase._hx_class = tink_streams_StreamBase


class tink_streams_IdealStreamBase(tink_streams_StreamBase):
    _hx_class_name = "tink.streams.IdealStreamBase"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["idealize"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = tink_streams_StreamBase


    def __init__(self):
        super().__init__()

    def idealize(self,rescue):
        return self

tink_streams_IdealStreamBase._hx_class = tink_streams_IdealStreamBase


class tink_streams__RealStream_RealStream_Impl_:
    _hx_class_name = "tink.streams._RealStream.RealStream_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["promiseOfIdealStream", "promiseOfStreamNoise", "promiseOfRealStream", "promiseOfStreamError", "collect"]

    @staticmethod
    def promiseOfIdealStream(p):
        return tink_streams__Stream_Stream_Impl_.promise(tink_core__Promise_Promise_Impl_.ofSpecific(p))

    @staticmethod
    def promiseOfStreamNoise(p):
        return tink_streams__Stream_Stream_Impl_.promise(p)

    @staticmethod
    def promiseOfRealStream(p):
        return tink_streams__Stream_Stream_Impl_.promise(tink_core__Promise_Promise_Impl_.ofSpecific(p))

    @staticmethod
    def promiseOfStreamError(p):
        return tink_streams__Stream_Stream_Impl_.promise(p)

    @staticmethod
    def collect(this1):
        buf = []
        def _hx_local_1(x):
            buf.append(x)
            return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(tink_streams_Handled.Resume))
        def _hx_local_0(c):
            ret = c.index
            if (ret == 0):
                _g = c.params[0]
                raise haxe_Exception.thrown("unreachable")
            elif (ret == 2):
                e = c.params[0]
                return tink_core_Outcome.Failure(e)
            elif (ret == 3):
                return tink_core_Outcome.Success(buf)
            else:
                pass
        ret = this1.forEach(tink_streams__Stream_Handler_Impl_.ofSafe(_hx_local_1)).map(_hx_local_0)
        return ret.gather()
tink_streams__RealStream_RealStream_Impl_._hx_class = tink_streams__RealStream_RealStream_Impl_


class tink_streams__Stream_Stream_Impl_:
    _hx_class_name = "tink.streams._Stream.Stream_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["get_depleted", "dirty", "single", "ofIterator", "flatten", "promiseIdeal", "promiseReal", "promise", "ofError"]
    depleted = None

    @staticmethod
    def get_depleted(this1):
        return this1.get_depleted()

    @staticmethod
    def dirty(this1):
        return this1

    @staticmethod
    def single(i):
        return tink_streams_Single(tink_core__Lazy_LazyConst(i))

    @staticmethod
    def ofIterator(i):
        next = None
        def _hx_local_0(step):
            step((tink_streams_Step.Link(i.next(),tink_streams_Generator.stream(next)) if (i.hasNext()) else tink_streams_Step.End))
        next = _hx_local_0
        return tink_streams_Generator.stream(next)

    @staticmethod
    def flatten(f):
        return tink_streams_FutureStream(f)

    @staticmethod
    def promiseIdeal(f):
        return tink_streams__Stream_Stream_Impl_.promise(tink_core__Promise_Promise_Impl_.ofSpecific(f))

    @staticmethod
    def promiseReal(f):
        return tink_streams__Stream_Stream_Impl_.promise(tink_core__Promise_Promise_Impl_.ofSpecific(f))

    @staticmethod
    def promise(f):
        def _hx_local_0(o):
            ret = o.index
            if (ret == 0):
                s = o.params[0]
                return tink_streams__Stream_Stream_Impl_.dirty(s)
            elif (ret == 1):
                e = o.params[0]
                return tink_streams__Stream_Stream_Impl_.ofError(e)
            else:
                pass
        ret = f.map(_hx_local_0)
        return tink_streams__Stream_Stream_Impl_.flatten(ret.gather())

    @staticmethod
    def ofError(e):
        return tink_streams__Stream_ErrorStream(e)
tink_streams__Stream_Stream_Impl_._hx_class = tink_streams__Stream_Stream_Impl_

class tink_streams_RegroupStatus(Enum):
    __slots__ = ()
    _hx_class_name = "tink.streams.RegroupStatus"
    _hx_constructs = ["Flowing", "Errored", "Ended"]

    @staticmethod
    def Errored(e):
        return tink_streams_RegroupStatus("Errored", 1, (e,))
tink_streams_RegroupStatus.Flowing = tink_streams_RegroupStatus("Flowing", 0, ())
tink_streams_RegroupStatus.Ended = tink_streams_RegroupStatus("Ended", 2, ())
tink_streams_RegroupStatus._hx_class = tink_streams_RegroupStatus

class tink_streams_RegroupResult(Enum):
    __slots__ = ()
    _hx_class_name = "tink.streams.RegroupResult"
    _hx_constructs = ["Converted", "Terminated", "Untouched", "Errored"]

    @staticmethod
    def Converted(data):
        return tink_streams_RegroupResult("Converted", 0, (data,))

    @staticmethod
    def Terminated(data):
        return tink_streams_RegroupResult("Terminated", 1, (data,))

    @staticmethod
    def Errored(e):
        return tink_streams_RegroupResult("Errored", 3, (e,))
tink_streams_RegroupResult.Untouched = tink_streams_RegroupResult("Untouched", 2, ())
tink_streams_RegroupResult._hx_class = tink_streams_RegroupResult


class tink_streams__Stream_Regrouper_Impl_:
    _hx_class_name = "tink.streams._Stream.Regrouper_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["ofIgnorance", "ofIgnoranceSync", "ofFunc", "ofFuncSync"]

    @staticmethod
    def ofIgnorance(f):
        def _hx_local_1():
            def _hx_local_0(i,_):
                return f(i)
            return _hx_AnonObject({'apply': _hx_local_0})
        return _hx_local_1()

    @staticmethod
    def ofIgnoranceSync(f):
        def _hx_local_1():
            def _hx_local_0(i,_):
                return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(f(i)))
            return _hx_AnonObject({'apply': _hx_local_0})
        return _hx_local_1()

    @staticmethod
    def ofFunc(f):
        return _hx_AnonObject({'apply': f})

    @staticmethod
    def ofFuncSync(f):
        def _hx_local_1():
            def _hx_local_0(i,s):
                return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(f(i,s)))
            return _hx_AnonObject({'apply': _hx_local_0})
        return _hx_local_1()
tink_streams__Stream_Regrouper_Impl_._hx_class = tink_streams__Stream_Regrouper_Impl_


class tink_streams__Stream_CompoundStream(tink_streams_StreamBase):
    _hx_class_name = "tink.streams._Stream.CompoundStream"
    _hx_is_interface = "False"
    __slots__ = ("parts",)
    _hx_fields = ["parts"]
    _hx_methods = ["get_depleted", "next", "decompose", "forEach"]
    _hx_statics = ["consumeParts", "of"]
    _hx_interfaces = []
    _hx_super = tink_streams_StreamBase


    def __init__(self,parts):
        self.parts = None
        super().__init__()
        self.parts = parts

    def get_depleted(self):
        _g = len(self.parts)
        if (_g == 0):
            return True
        elif (_g == 1):
            return (self.parts[0] if 0 < len(self.parts) else None).get_depleted()
        else:
            return False

    def next(self):
        _gthis = self
        if (len(self.parts) == 0):
            return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(tink_streams_Step.End))
        else:
            def _hx_local_0(v):
                ret = v.index
                if (ret == 0):
                    rest = v.params[1]
                    v1 = v.params[0]
                    copy = list(_gthis.parts)
                    python_internal_ArrayImpl._set(copy, 0, rest)
                    return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(tink_streams_Step.Link(v1,tink_streams__Stream_CompoundStream(copy))))
                elif (ret == 2):
                    if (len(_gthis.parts) > 1):
                        return (_gthis.parts[1] if 1 < len(_gthis.parts) else None).next()
                    else:
                        return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(v))
                else:
                    return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(v))
            ret = (self.parts[0] if 0 < len(self.parts) else None).next().flatMap(_hx_local_0)
            return ret.gather()

    def decompose(self,into):
        _g = 0
        _g1 = self.parts
        while (_g < len(_g1)):
            p = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            p.decompose(into)

    def forEach(self,handler):
        parts = self.parts
        handler1 = handler
        def _hx_local_1():
            def _hx_local_0(cb):
                tink_streams__Stream_CompoundStream.consumeParts(parts,handler1,cb)
            return tink_core__Future_Future_Impl_.make(_hx_local_0)
        return _hx_local_1()

    @staticmethod
    def consumeParts(parts,handler,cb):
        if (len(parts) == 0):
            cb(tink_streams_Conclusion.Depleted)
        else:
            def _hx_local_0(o):
                nonlocal parts
                nonlocal parts
                nonlocal parts
                tmp = o.index
                if (tmp == 0):
                    rest = o.params[0]
                    parts = list(parts)
                    python_internal_ArrayImpl._set(parts, 0, rest)
                    cb(tink_streams_Conclusion.Halted(tink_streams__Stream_CompoundStream(parts)))
                elif (tmp == 1):
                    at = o.params[1]
                    e = o.params[0]
                    if at.get_depleted():
                        parts = parts[1:None]
                    else:
                        parts = list(parts)
                        python_internal_ArrayImpl._set(parts, 0, at)
                    cb(tink_streams_Conclusion.Clogged(e,tink_streams__Stream_CompoundStream(parts)))
                elif (tmp == 2):
                    e = o.params[0]
                    cb(tink_streams_Conclusion.Failed(e))
                elif (tmp == 3):
                    tink_streams__Stream_CompoundStream.consumeParts(parts[1:None],handler,cb)
                else:
                    pass
            (parts[0] if 0 < len(parts) else None).forEach(handler).handle(_hx_local_0)

    @staticmethod
    def of(streams):
        ret = []
        _g = 0
        while (_g < len(streams)):
            s = (streams[_g] if _g >= 0 and _g < len(streams) else None)
            _g = (_g + 1)
            s.decompose(ret)
        if (len(ret) == 0):
            return tink_streams_Empty.inst
        else:
            return tink_streams__Stream_CompoundStream(ret)

tink_streams__Stream_CompoundStream._hx_class = tink_streams__Stream_CompoundStream


class tink_streams__Stream_RegroupStream(tink_streams__Stream_CompoundStream):
    _hx_class_name = "tink.streams._Stream.RegroupStream"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = []
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = tink_streams__Stream_CompoundStream


    def __init__(self,source,f,prev = None):
        if (prev is None):
            prev = tink_streams_Empty.inst
        ret = None
        terminated = False
        buf = []
        def _hx_local_3(item):
            buf.append(item)
            def _hx_local_2(o):
                nonlocal terminated
                nonlocal ret
                nonlocal ret
                nonlocal ret
                ret1 = o.index
                if (ret1 == 0):
                    v = o.params[0]
                    ret = v
                    return tink_streams_Handled.Finish
                elif (ret1 == 1):
                    v = o.params[0]
                    l = tink_core__Lazy_LazyFunc(tink_streams_Empty.make)
                    if (v.index == 0):
                        v1 = v.params[0]
                        ret = v1
                    else:
                        ret = l.get()
                    terminated = True
                    return tink_streams_Handled.Finish
                elif (ret1 == 2):
                    return tink_streams_Handled.Resume
                elif (ret1 == 3):
                    e = o.params[0]
                    return tink_streams_Handled.Clog(e)
                else:
                    pass
            ret1 = f.apply(buf,tink_streams_RegroupStatus.Flowing).map(_hx_local_2)
            return ret1.gather()
        def _hx_local_1(o):
            ret1 = o.index
            if (ret1 == 0):
                if terminated:
                    return ret
                else:
                    rest = o.params[0]
                    return tink_streams__Stream_RegroupStream(rest,f,ret)
            elif (ret1 == 1):
                rest = o.params[1]
                e = o.params[0]
                return tink_streams__Stream_CloggedStream(tink_streams__Stream_Stream_Impl_.ofError(e),rest)
            elif (ret1 == 2):
                e = o.params[0]
                return tink_streams__Stream_Stream_Impl_.ofError(e)
            elif (ret1 == 3):
                if (len(buf) == 0):
                    return tink_streams_Empty.inst
                else:
                    def _hx_local_0(o):
                        ret = o.index
                        if (ret == 0):
                            v = o.params[0]
                            return v
                        elif (ret == 1):
                            v = o.params[0]
                            l = tink_core__Lazy_LazyFunc(tink_streams_Empty.make)
                            if (v.index == 0):
                                v1 = v.params[0]
                                return v1
                            else:
                                return l.get()
                        elif (ret == 2):
                            return tink_streams_Empty.inst
                        elif (ret == 3):
                            e = o.params[0]
                            return tink_streams__Stream_Stream_Impl_.ofError(e)
                        else:
                            pass
                    ret1 = f.apply(buf,tink_streams_RegroupStatus.Ended).map(_hx_local_0)
                    return tink_streams__Stream_Stream_Impl_.flatten(ret1.gather())
            else:
                pass
        ret1 = source.forEach(tink_streams__Stream_Handler_Impl_.ofUnknown(_hx_local_3)).map(_hx_local_1)
        next = tink_streams__Stream_Stream_Impl_.flatten(ret1.gather())
        super().__init__([prev, next])
tink_streams__Stream_RegroupStream._hx_class = tink_streams__Stream_RegroupStream

class tink_streams_Handled(Enum):
    __slots__ = ()
    _hx_class_name = "tink.streams.Handled"
    _hx_constructs = ["BackOff", "Finish", "Resume", "Clog"]

    @staticmethod
    def Clog(e):
        return tink_streams_Handled("Clog", 3, (e,))
tink_streams_Handled.BackOff = tink_streams_Handled("BackOff", 0, ())
tink_streams_Handled.Finish = tink_streams_Handled("Finish", 1, ())
tink_streams_Handled.Resume = tink_streams_Handled("Resume", 2, ())
tink_streams_Handled._hx_class = tink_streams_Handled

class tink_streams_Conclusion(Enum):
    __slots__ = ()
    _hx_class_name = "tink.streams.Conclusion"
    _hx_constructs = ["Halted", "Clogged", "Failed", "Depleted"]

    @staticmethod
    def Halted(rest):
        return tink_streams_Conclusion("Halted", 0, (rest,))

    @staticmethod
    def Clogged(error,at):
        return tink_streams_Conclusion("Clogged", 1, (error,at))

    @staticmethod
    def Failed(error):
        return tink_streams_Conclusion("Failed", 2, (error,))
tink_streams_Conclusion.Depleted = tink_streams_Conclusion("Depleted", 3, ())
tink_streams_Conclusion._hx_class = tink_streams_Conclusion

class tink_streams_ReductionStep(Enum):
    __slots__ = ()
    _hx_class_name = "tink.streams.ReductionStep"
    _hx_constructs = ["Progress", "Crash"]

    @staticmethod
    def Progress(result):
        return tink_streams_ReductionStep("Progress", 0, (result,))

    @staticmethod
    def Crash(e):
        return tink_streams_ReductionStep("Crash", 1, (e,))
tink_streams_ReductionStep._hx_class = tink_streams_ReductionStep

class tink_streams_Reduction(Enum):
    __slots__ = ()
    _hx_class_name = "tink.streams.Reduction"
    _hx_constructs = ["Crashed", "Failed", "Reduced"]

    @staticmethod
    def Crashed(error,at):
        return tink_streams_Reduction("Crashed", 0, (error,at))

    @staticmethod
    def Failed(error):
        return tink_streams_Reduction("Failed", 1, (error,))

    @staticmethod
    def Reduced(result):
        return tink_streams_Reduction("Reduced", 2, (result,))
tink_streams_Reduction._hx_class = tink_streams_Reduction


class tink_streams__Stream_CloggedStream(tink_streams_StreamBase):
    _hx_class_name = "tink.streams._Stream.CloggedStream"
    _hx_is_interface = "False"
    __slots__ = ("rest", "error")
    _hx_fields = ["rest", "error"]
    _hx_methods = ["next", "forEach"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = tink_streams_StreamBase


    def __init__(self,rest,error):
        self.error = None
        self.rest = None
        super().__init__()
        self.rest = rest
        self.error = error

    def next(self):
        return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(tink_streams_Step.Fail(self.error)))

    def forEach(self,handler):
        return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(tink_streams_Conclusion.Clogged(self.error,self.rest)))

tink_streams__Stream_CloggedStream._hx_class = tink_streams__Stream_CloggedStream


class tink_streams__Stream_ErrorStream(tink_streams_StreamBase):
    _hx_class_name = "tink.streams._Stream.ErrorStream"
    _hx_is_interface = "False"
    __slots__ = ("error",)
    _hx_fields = ["error"]
    _hx_methods = ["next", "forEach"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = tink_streams_StreamBase


    def __init__(self,error):
        self.error = None
        super().__init__()
        self.error = error

    def next(self):
        return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(tink_streams_Step.Fail(self.error)))

    def forEach(self,handler):
        return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(tink_streams_Conclusion.Failed(self.error)))

tink_streams__Stream_ErrorStream._hx_class = tink_streams__Stream_ErrorStream


class tink_streams_Empty(tink_streams_StreamBase):
    _hx_class_name = "tink.streams.Empty"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["get_depleted", "next", "forEach"]
    _hx_statics = ["inst", "make"]
    _hx_interfaces = []
    _hx_super = tink_streams_StreamBase


    def __init__(self):
        super().__init__()

    def get_depleted(self):
        return True

    def next(self):
        return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(tink_streams_Step.End))

    def forEach(self,handler):
        return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(tink_streams_Conclusion.Depleted))

    @staticmethod
    def make():
        return tink_streams_Empty.inst

tink_streams_Empty._hx_class = tink_streams_Empty


class tink_streams__Stream_Mapping_Impl_:
    _hx_class_name = "tink.streams._Stream.Mapping_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["_new", "ofNext", "ofAsync", "ofSync", "ofPlain"]

    @staticmethod
    def _new(o):
        this1 = o
        return this1

    @staticmethod
    def ofNext(n):
        def _hx_local_2(i,_):
            def _hx_local_0(o):
                return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(tink_core_Outcome.Success(tink_streams_RegroupResult.Converted(tink_streams__Stream_Stream_Impl_.single(o)))))
            this1 = tink_core__Promise_Promise_Impl_.next(n((i[0] if 0 < len(i) else None)),_hx_local_0)
            f = tink_core__Promise_Recover_Impl_.ofSync(tink_streams_RegroupResult.Errored)
            def _hx_local_1(o):
                ret = o.index
                if (ret == 0):
                    d = o.params[0]
                    return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(d))
                elif (ret == 1):
                    e = o.params[0]
                    return f(e)
                else:
                    pass
            ret = this1.flatMap(_hx_local_1)
            return ret.gather()
        this1 = _hx_AnonObject({'apply': _hx_local_2})
        return this1

    @staticmethod
    def ofAsync(f):
        def _hx_local_1(i,_):
            def _hx_local_0(o):
                return tink_streams_RegroupResult.Converted(tink_streams__Stream_Stream_Impl_.single(o))
            ret = f((i[0] if 0 < len(i) else None)).map(_hx_local_0)
            return ret.gather()
        this1 = _hx_AnonObject({'apply': _hx_local_1})
        return this1

    @staticmethod
    def ofSync(f):
        def _hx_local_0(i,_):
            v = None
            _g = f((i[0] if 0 < len(i) else None))
            v1 = _g.index
            if (v1 == 0):
                v1 = _g.params[0]
                v = tink_streams_RegroupResult.Converted(tink_streams__Stream_Stream_Impl_.single(v1))
            elif (v1 == 1):
                e = _g.params[0]
                v = tink_streams_RegroupResult.Errored(e)
            else:
                pass
            return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(v))
        this1 = _hx_AnonObject({'apply': _hx_local_0})
        return this1

    @staticmethod
    def ofPlain(f):
        def _hx_local_0(i,_):
            return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(tink_streams_RegroupResult.Converted(tink_streams__Stream_Stream_Impl_.single(f((i[0] if 0 < len(i) else None))))))
        this1 = _hx_AnonObject({'apply': _hx_local_0})
        return this1
tink_streams__Stream_Mapping_Impl_._hx_class = tink_streams__Stream_Mapping_Impl_


class tink_streams__Stream_Filter_Impl_:
    _hx_class_name = "tink.streams._Stream.Filter_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["_new", "ofNext", "ofAsync", "ofSync", "ofPlain"]

    @staticmethod
    def _new(o):
        this1 = o
        return this1

    @staticmethod
    def ofNext(n):
        def _hx_local_2(i,_):
            def _hx_local_0(matched):
                return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(tink_core_Outcome.Success(tink_streams_RegroupResult.Converted((tink_streams__Stream_Stream_Impl_.single((i[0] if 0 < len(i) else None)) if matched else tink_streams_Empty.inst)))))
            this1 = tink_core__Promise_Promise_Impl_.next(n((i[0] if 0 < len(i) else None)),_hx_local_0)
            f = tink_core__Promise_Recover_Impl_.ofSync(tink_streams_RegroupResult.Errored)
            def _hx_local_1(o):
                ret = o.index
                if (ret == 0):
                    d = o.params[0]
                    return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(d))
                elif (ret == 1):
                    e = o.params[0]
                    return f(e)
                else:
                    pass
            ret = this1.flatMap(_hx_local_1)
            return ret.gather()
        this1 = _hx_AnonObject({'apply': _hx_local_2})
        return this1

    @staticmethod
    def ofAsync(f):
        def _hx_local_1(i,_):
            def _hx_local_0(matched):
                return tink_streams_RegroupResult.Converted((tink_streams__Stream_Stream_Impl_.single((i[0] if 0 < len(i) else None)) if matched else tink_streams_Empty.inst))
            ret = f((i[0] if 0 < len(i) else None)).map(_hx_local_0)
            return ret.gather()
        this1 = _hx_AnonObject({'apply': _hx_local_1})
        return this1

    @staticmethod
    def ofSync(f):
        def _hx_local_0(i,_):
            v = None
            _g = f((i[0] if 0 < len(i) else None))
            v1 = _g.index
            if (v1 == 0):
                v1 = _g.params[0]
                v = tink_streams_RegroupResult.Converted((tink_streams__Stream_Stream_Impl_.single((i[0] if 0 < len(i) else None)) if v1 else tink_streams_Empty.inst))
            elif (v1 == 1):
                e = _g.params[0]
                v = tink_streams_RegroupResult.Errored(e)
            else:
                pass
            return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(v))
        this1 = _hx_AnonObject({'apply': _hx_local_0})
        return this1

    @staticmethod
    def ofPlain(f):
        def _hx_local_0(i,_):
            return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(tink_streams_RegroupResult.Converted((tink_streams__Stream_Stream_Impl_.single((i[0] if 0 < len(i) else None)) if (f((i[0] if 0 < len(i) else None))) else tink_streams_Empty.inst))))
        this1 = _hx_AnonObject({'apply': _hx_local_0})
        return this1
tink_streams__Stream_Filter_Impl_._hx_class = tink_streams__Stream_Filter_Impl_


class tink_streams_IdealizeStream(tink_streams_IdealStreamBase):
    _hx_class_name = "tink.streams.IdealizeStream"
    _hx_is_interface = "False"
    __slots__ = ("target", "rescue")
    _hx_fields = ["target", "rescue"]
    _hx_methods = ["get_depleted", "next", "forEach"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = tink_streams_IdealStreamBase


    def __init__(self,target,rescue):
        self.rescue = None
        self.target = None
        super().__init__()
        self.target = target
        self.rescue = rescue

    def get_depleted(self):
        return self.target.get_depleted()

    def next(self):
        _gthis = self
        def _hx_local_0(v):
            if (v.index == 1):
                e = v.params[0]
                return _gthis.rescue(e).idealize(_gthis.rescue).next()
            else:
                return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(v))
        ret = self.target.next().flatMap(_hx_local_0)
        return ret.gather()

    def forEach(self,handler):
        _gthis = self
        def _hx_local_2():
            def _hx_local_1(cb):
                def _hx_local_0(end):
                    tmp = end.index
                    if (tmp == 0):
                        rest = end.params[0]
                        cb(tink_streams_Conclusion.Halted(rest.idealize(_gthis.rescue)))
                    elif (tmp == 1):
                        at = end.params[1]
                        e = end.params[0]
                        cb(tink_streams_Conclusion.Clogged(e,at.idealize(_gthis.rescue)))
                    elif (tmp == 2):
                        e = end.params[0]
                        _gthis.rescue(e).idealize(_gthis.rescue).forEach(handler).handle(cb)
                    elif (tmp == 3):
                        cb(tink_streams_Conclusion.Depleted)
                    else:
                        pass
                _gthis.target.forEach(handler).handle(_hx_local_0)
            return tink_core__Future_Future_Impl_.make(_hx_local_1)
        return _hx_local_2()

tink_streams_IdealizeStream._hx_class = tink_streams_IdealizeStream


class tink_streams_Single(tink_streams_StreamBase):
    _hx_class_name = "tink.streams.Single"
    _hx_is_interface = "False"
    __slots__ = ("value",)
    _hx_fields = ["value"]
    _hx_methods = ["next", "forEach"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = tink_streams_StreamBase


    def __init__(self,value):
        self.value = None
        super().__init__()
        self.value = value

    def next(self):
        return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(tink_streams_Step.Link(self.value.get(),tink_streams_Empty.inst)))

    def forEach(self,handle):
        _gthis = self
        def _hx_local_0(step):
            ret = step.index
            if (ret == 0):
                return tink_streams_Conclusion.Halted(_gthis)
            elif (ret == 1):
                return tink_streams_Conclusion.Halted(tink_streams_Empty.inst)
            elif (ret == 2):
                return tink_streams_Conclusion.Depleted
            elif (ret == 3):
                e = step.params[0]
                return tink_streams_Conclusion.Clogged(e,_gthis)
            else:
                pass
        ret = handle(self.value.get()).map(_hx_local_0)
        return ret.gather()

tink_streams_Single._hx_class = tink_streams_Single


class tink_streams__Stream_Handler_Impl_:
    _hx_class_name = "tink.streams._Stream.Handler_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["_new", "apply", "ofSafeSync", "ofUnknownSync", "ofSafe", "ofUnknown"]

    @staticmethod
    def _new(f):
        this1 = f
        return this1

    @staticmethod
    def apply(this1,item):
        return this1(item)

    @staticmethod
    def ofSafeSync(f):
        def _hx_local_0(i):
            return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(f(i)))
        this1 = _hx_local_0
        return this1

    @staticmethod
    def ofUnknownSync(f):
        def _hx_local_0(i):
            return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(f(i)))
        this1 = _hx_local_0
        return this1

    @staticmethod
    def ofSafe(f):
        this1 = f
        return this1

    @staticmethod
    def ofUnknown(f):
        this1 = f
        return this1
tink_streams__Stream_Handler_Impl_._hx_class = tink_streams__Stream_Handler_Impl_


class tink_streams__Stream_Reducer_Impl_:
    _hx_class_name = "tink.streams._Stream.Reducer_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["_new", "apply", "ofSafeSync", "ofUnknownSync", "ofSafe", "ofPlainSync", "ofUnknown", "ofPromiseBased"]

    @staticmethod
    def _new(f):
        this1 = f
        return this1

    @staticmethod
    def apply(this1,res,item):
        return this1(res,item)

    @staticmethod
    def ofSafeSync(f):
        def _hx_local_0(res,cur):
            return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(f(res,cur)))
        this1 = _hx_local_0
        return this1

    @staticmethod
    def ofUnknownSync(f):
        def _hx_local_0(res,cur):
            return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(f(res,cur)))
        this1 = _hx_local_0
        return this1

    @staticmethod
    def ofSafe(f):
        this1 = f
        return this1

    @staticmethod
    def ofPlainSync(f):
        def _hx_local_0(res,cur):
            return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(tink_streams_ReductionStep.Progress(f(res,cur))))
        this1 = _hx_local_0
        return this1

    @staticmethod
    def ofUnknown(f):
        this1 = f
        return this1

    @staticmethod
    def ofPromiseBased(f):
        def _hx_local_1(res,cur):
            def _hx_local_0(s):
                ret = s.index
                if (ret == 0):
                    r = s.params[0]
                    return tink_streams_ReductionStep.Progress(r)
                elif (ret == 1):
                    e = s.params[0]
                    return tink_streams_ReductionStep.Crash(e)
                else:
                    pass
            ret = f(res,cur).map(_hx_local_0)
            return ret.gather()
        this1 = _hx_local_1
        return this1
tink_streams__Stream_Reducer_Impl_._hx_class = tink_streams__Stream_Reducer_Impl_


class tink_streams_FutureStream(tink_streams_StreamBase):
    _hx_class_name = "tink.streams.FutureStream"
    _hx_is_interface = "False"
    __slots__ = ("f",)
    _hx_fields = ["f"]
    _hx_methods = ["next", "forEach"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = tink_streams_StreamBase


    def __init__(self,f):
        self.f = None
        super().__init__()
        self.f = f

    def next(self):
        def _hx_local_0(s):
            return s.next()
        ret = self.f.flatMap(_hx_local_0)
        return ret.gather()

    def forEach(self,handler):
        _gthis = self
        def _hx_local_2():
            def _hx_local_1(cb):
                def _hx_local_0(s):
                    s.forEach(handler).handle(cb)
                _gthis.f.handle(_hx_local_0)
            return tink_core__Future_Future_Impl_.make(_hx_local_1)
        return _hx_local_2()

tink_streams_FutureStream._hx_class = tink_streams_FutureStream


class tink_streams_Generator(tink_streams_StreamBase):
    _hx_class_name = "tink.streams.Generator"
    _hx_is_interface = "False"
    __slots__ = ("upcoming",)
    _hx_fields = ["upcoming"]
    _hx_methods = ["next", "forEach"]
    _hx_statics = ["stream"]
    _hx_interfaces = []
    _hx_super = tink_streams_StreamBase


    def __init__(self,upcoming):
        self.upcoming = None
        super().__init__()
        self.upcoming = upcoming

    def next(self):
        return self.upcoming

    def forEach(self,handler):
        _gthis = self
        def _hx_local_3():
            def _hx_local_2(cb):
                def _hx_local_1(e):
                    tmp = e.index
                    if (tmp == 0):
                        then = e.params[1]
                        v = e.params[0]
                        def _hx_local_0(s):
                            tmp = s.index
                            if (tmp == 0):
                                cb(tink_streams_Conclusion.Halted(_gthis))
                            elif (tmp == 1):
                                cb(tink_streams_Conclusion.Halted(then))
                            elif (tmp == 2):
                                then.forEach(handler).handle(cb)
                            elif (tmp == 3):
                                e = s.params[0]
                                cb(tink_streams_Conclusion.Clogged(e,_gthis))
                            else:
                                pass
                        handler(v).handle(_hx_local_0)
                    elif (tmp == 1):
                        e1 = e.params[0]
                        cb(tink_streams_Conclusion.Failed(e1))
                    elif (tmp == 2):
                        cb(tink_streams_Conclusion.Depleted)
                    else:
                        pass
                _gthis.upcoming.handle(_hx_local_1)
            return tink_core__Future_Future_Impl_.make(_hx_local_2,True)
        return _hx_local_3()

    @staticmethod
    def stream(step):
        return tink_streams_Generator(tink_core__Future_Future_Impl_.make(step,True))

tink_streams_Generator._hx_class = tink_streams_Generator


class tink_streams_BlendStream(tink_streams_Generator):
    _hx_class_name = "tink.streams.BlendStream"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = []
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = tink_streams_Generator


    def __init__(self,a,b):
        first = None
        def _hx_local_1(s):
            def _hx_local_0(o):
                nonlocal first
                if (first is None):
                    first = s
                return o
            ret = s.next().map(_hx_local_0)
            return ret.gather()
        wait = _hx_local_1
        n1 = wait(a)
        n2 = wait(b)
        def _hx_local_3(cb):
            def _hx_local_2(o):
                tmp = o.index
                if (tmp == 0):
                    rest = o.params[1]
                    item = o.params[0]
                    cb(tink_streams_Step.Link(item,tink_streams_BlendStream(rest,(b if ((first == a)) else a))))
                elif (tmp == 1):
                    e = o.params[0]
                    cb(tink_streams_Step.Fail(e))
                elif (tmp == 2):
                    ((n2 if ((first == a)) else n1)).handle(cb)
                else:
                    pass
            tink_core__Future_Future_Impl_.first(n1,n2).handle(_hx_local_2)
        super().__init__(tink_core__Future_Future_Impl_.make(_hx_local_3))
tink_streams_BlendStream._hx_class = tink_streams_BlendStream

class tink_streams_Step(Enum):
    __slots__ = ()
    _hx_class_name = "tink.streams.Step"
    _hx_constructs = ["Link", "Fail", "End"]

    @staticmethod
    def Link(value,next):
        return tink_streams_Step("Link", 0, (value,next))

    @staticmethod
    def Fail(e):
        return tink_streams_Step("Fail", 1, (e,))
tink_streams_Step.End = tink_streams_Step("End", 2, ())
tink_streams_Step._hx_class = tink_streams_Step


class tink_streams_SignalStream(tink_streams_Generator):
    _hx_class_name = "tink.streams.SignalStream"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = []
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = tink_streams_Generator


    def __init__(self,signal):
        def _hx_local_0(o):
            ret = o.index
            if (ret == 0):
                data = o.params[0]
                return tink_streams_Step.Link(data,tink_streams_SignalStream(signal))
            elif (ret == 1):
                e = o.params[0]
                return tink_streams_Step.Fail(e)
            elif (ret == 2):
                return tink_streams_Step.End
            else:
                pass
        ret = tink_core__Signal_Signal_Impl_.nextTime(signal).map(_hx_local_0)
        super().__init__(ret.gather())
tink_streams_SignalStream._hx_class = tink_streams_SignalStream

class tink_streams_Yield(Enum):
    __slots__ = ()
    _hx_class_name = "tink.streams.Yield"
    _hx_constructs = ["Data", "Fail", "End"]

    @staticmethod
    def Data(data):
        return tink_streams_Yield("Data", 0, (data,))

    @staticmethod
    def Fail(e):
        return tink_streams_Yield("Fail", 1, (e,))
tink_streams_Yield.End = tink_streams_Yield("End", 2, ())
tink_streams_Yield._hx_class = tink_streams_Yield


class tink_testrunner_Assertion:
    _hx_class_name = "tink.testrunner.Assertion"
    _hx_is_interface = "False"
    __slots__ = ("holds", "description", "pos")
    _hx_fields = ["holds", "description", "pos"]

    def __init__(self,holds,description,pos = None):
        self.holds = holds
        self.description = description
        self.pos = pos

tink_testrunner_Assertion._hx_class = tink_testrunner_Assertion


class tink_testrunner__Assertion_AssertionResult_Impl_:
    _hx_class_name = "tink.testrunner._Assertion.AssertionResult_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["ofBool", "ofOutcome", "toBool", "not", "and_", "or_", "_and", "_or"]

    @staticmethod
    def ofBool(v):
        if v:
            return tink_core_Outcome.Success(tink_core_Noise.Noise)
        else:
            return tink_core_Outcome.Failure(None)

    @staticmethod
    def ofOutcome(v):
        tmp = v.index
        if (tmp == 0):
            _g = v.params[0]
            return tink_core_Outcome.Success(tink_core_Noise.Noise)
        elif (tmp == 1):
            e = v.params[0]
            return tink_core_Outcome.Failure(((("" + HxOverrides.stringOrNull(e.toString())) + " ") + Std.string(e.data)))
        else:
            pass

    @staticmethod
    def toBool(this1):
        return tink_core_OutcomeTools.isSuccess(this1)

    @staticmethod
    def _hx_not(this1):
        return (not tink_core_OutcomeTools.isSuccess(this1))

    @staticmethod
    def and_(a,b):
        if tink_core_OutcomeTools.isSuccess(a):
            return b
        else:
            return False

    @staticmethod
    def or_(a,b):
        if (not tink_core_OutcomeTools.isSuccess(a)):
            return b
        else:
            return True

    @staticmethod
    def _and(a,b):
        if a:
            return tink_core_OutcomeTools.isSuccess(b)
        else:
            return False

    @staticmethod
    def _or(a,b):
        if (not a):
            return tink_core_OutcomeTools.isSuccess(b)
        else:
            return True
tink_testrunner__Assertion_AssertionResult_Impl_._hx_class = tink_testrunner__Assertion_AssertionResult_Impl_


class tink_testrunner__Assertions_Assertions_Impl_:
    _hx_class_name = "tink.testrunner._Assertions.Assertions_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["ofAssertion", "ofArray", "ofPromiseArray", "ofFutureAssertion", "ofFutureAssertions", "ofSurpriseAssertion", "ofOutcomeAssertions", "ofPromiseAssertions", "ofSurpriseAssertions"]

    @staticmethod
    def ofAssertion(o):
        return tink_streams__Stream_Stream_Impl_.ofIterator(haxe_iterators_ArrayIterator([o]))

    @staticmethod
    def ofArray(o):
        return tink_streams__Stream_Stream_Impl_.ofIterator(haxe_iterators_ArrayIterator(o))

    @staticmethod
    def ofPromiseArray(o):
        def _hx_local_1():
            def _hx_local_0(o):
                return tink_streams__Stream_Stream_Impl_.ofIterator(haxe_iterators_ArrayIterator(o))
            return tink_streams__Stream_Stream_Impl_.promise(tink_core__Promise_Promise_Impl_.next(o,tink_core__Promise_Next_Impl_.ofSafeSync(_hx_local_0)))
        return _hx_local_1()

    @staticmethod
    def ofFutureAssertion(p):
        def _hx_local_0(a):
            return tink_core_Outcome.Success(tink_streams__Stream_Stream_Impl_.ofIterator(haxe_iterators_ArrayIterator([a])))
        ret = p.map(_hx_local_0)
        return tink_streams__Stream_Stream_Impl_.promise(ret.gather())

    @staticmethod
    def ofFutureAssertions(p):
        ret = p.map(tink_core_Outcome.Success)
        return tink_streams__Stream_Stream_Impl_.promise(ret.gather())

    @staticmethod
    def ofSurpriseAssertion(p):
        def _hx_local_1():
            def _hx_local_0(o):
                return tink_streams__Stream_Stream_Impl_.ofIterator(haxe_iterators_ArrayIterator([o]))
            return tink_streams__Stream_Stream_Impl_.promise(tink_core__Future_Future_Impl_._tryMap(p,_hx_local_0))
        return _hx_local_1()

    @staticmethod
    def ofOutcomeAssertions(o):
        return tink_streams__Stream_Stream_Impl_.promise(tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(o)))

    @staticmethod
    def ofPromiseAssertions(p):
        return tink_streams__Stream_Stream_Impl_.promise(p)

    @staticmethod
    def ofSurpriseAssertions(p):
        return tink_streams__Stream_Stream_Impl_.promise(p)
tink_testrunner__Assertions_Assertions_Impl_._hx_class = tink_testrunner__Assertions_Assertions_Impl_


class tink_testrunner__Batch_Batch_Impl_:
    _hx_class_name = "tink.testrunner._Batch.Batch_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["_new", "ofSuites", "ofSuite", "ofCases", "ofCase", "get_suites"]
    suites = None

    @staticmethod
    def _new(suites):
        this1 = suites
        return this1

    @staticmethod
    def ofSuites(suites):
        this1 = suites
        return this1

    @staticmethod
    def ofSuite(suite):
        this1 = [suite]
        return this1

    @staticmethod
    def ofCases(cases,pos = None):
        _g = []
        _g1 = 0
        while (_g1 < len(cases)):
            c = (cases[_g1] if _g1 >= 0 and _g1 < len(cases) else None)
            _g1 = (_g1 + 1)
            x = None
            _g2 = Type.getClass(c)
            if (_g2 is None):
                x = None
            else:
                c1 = _g2
                x = Type.getClassName(c1)
            _g.append(x)
        this1 = [tink_testrunner_BasicSuite(_hx_AnonObject({'name': ", ".join([python_Boot.toString1(x1,'') for x1 in _g]), 'pos': pos}),cases,_hx_AnonObject({'fileName': "tink/testrunner/Suite.hx", 'lineNumber': 36, 'className': "tink.testrunner._Suite.Suite_Impl_", 'methodName': "ofCases"}))]
        return this1

    @staticmethod
    def ofCase(caze,pos = None):
        cases = [caze]
        _g = []
        _g1 = 0
        while (_g1 < len(cases)):
            c = (cases[_g1] if _g1 >= 0 and _g1 < len(cases) else None)
            _g1 = (_g1 + 1)
            x = None
            _g2 = Type.getClass(c)
            if (_g2 is None):
                x = None
            else:
                c1 = _g2
                x = Type.getClassName(c1)
            _g.append(x)
        this1 = [tink_testrunner_BasicSuite(_hx_AnonObject({'name': ", ".join([python_Boot.toString1(x1,'') for x1 in _g]), 'pos': pos}),cases,_hx_AnonObject({'fileName': "tink/testrunner/Suite.hx", 'lineNumber': 36, 'className': "tink.testrunner._Suite.Suite_Impl_", 'methodName': "ofCases"}))]
        return this1

    @staticmethod
    def get_suites(this1):
        return this1
tink_testrunner__Batch_Batch_Impl_._hx_class = tink_testrunner__Batch_Batch_Impl_


class tink_testrunner__Case_Case_Impl_:
    _hx_class_name = "tink.testrunner._Case.Case_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["shouldRun"]

    @staticmethod
    def shouldRun(this1,includeMode):
        if (not this1.exclude):
            if includeMode:
                return this1.include
            else:
                return True
        else:
            return False
tink_testrunner__Case_Case_Impl_._hx_class = tink_testrunner__Case_Case_Impl_


class tink_testrunner_CaseObject:
    _hx_class_name = "tink.testrunner.CaseObject"
    _hx_is_interface = "True"
    __slots__ = ("suite", "info", "timeout", "include", "exclude", "pos")
    _hx_fields = ["suite", "info", "timeout", "include", "exclude", "pos"]
    _hx_methods = ["execute"]
tink_testrunner_CaseObject._hx_class = tink_testrunner_CaseObject


class tink_testrunner_BasicCase:
    _hx_class_name = "tink.testrunner.BasicCase"
    _hx_is_interface = "False"
    __slots__ = ("suite", "info", "timeout", "include", "exclude", "pos")
    _hx_fields = ["suite", "info", "timeout", "include", "exclude", "pos"]
    _hx_methods = ["execute"]
    _hx_interfaces = [tink_testrunner_CaseObject]

    def __init__(self,pos = None):
        self.info = None
        self.suite = None
        self.pos = None
        self.exclude = False
        self.include = False
        self.timeout = 5000
        self.info = _hx_AnonObject({'name': Type.getClassName(Type.getClass(self)), 'description': None, 'pos': pos})

    def execute(self):
        return tink_streams__Stream_Stream_Impl_.ofIterator(haxe_iterators_ArrayIterator([]))

tink_testrunner_BasicCase._hx_class = tink_testrunner_BasicCase


class tink_testrunner_Reporter:
    _hx_class_name = "tink.testrunner.Reporter"
    _hx_is_interface = "True"
    __slots__ = ()
    _hx_methods = ["report"]
tink_testrunner_Reporter._hx_class = tink_testrunner_Reporter

class tink_testrunner_ReportType(Enum):
    __slots__ = ()
    _hx_class_name = "tink.testrunner.ReportType"
    _hx_constructs = ["BatchStart", "SuiteStart", "CaseStart", "Assertion", "CaseFinish", "SuiteFinish", "BatchFinish"]

    @staticmethod
    def SuiteStart(info,hasCasesToRun):
        return tink_testrunner_ReportType("SuiteStart", 1, (info,hasCasesToRun))

    @staticmethod
    def CaseStart(info,shouldRun):
        return tink_testrunner_ReportType("CaseStart", 2, (info,shouldRun))

    @staticmethod
    def Assertion(assertion):
        return tink_testrunner_ReportType("Assertion", 3, (assertion,))

    @staticmethod
    def CaseFinish(result):
        return tink_testrunner_ReportType("CaseFinish", 4, (result,))

    @staticmethod
    def SuiteFinish(result):
        return tink_testrunner_ReportType("SuiteFinish", 5, (result,))

    @staticmethod
    def BatchFinish(result):
        return tink_testrunner_ReportType("BatchFinish", 6, (result,))
tink_testrunner_ReportType.BatchStart = tink_testrunner_ReportType("BatchStart", 0, ())
tink_testrunner_ReportType._hx_class = tink_testrunner_ReportType


class tink_testrunner_Formatter:
    _hx_class_name = "tink.testrunner.Formatter"
    _hx_is_interface = "True"
    __slots__ = ()
    _hx_methods = ["success", "error", "warning", "info", "extra", "mute", "normal", "color"]
tink_testrunner_Formatter._hx_class = tink_testrunner_Formatter


class tink_testrunner_BasicFormatter:
    _hx_class_name = "tink.testrunner.BasicFormatter"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_methods = ["success", "error", "warning", "info", "extra", "mute", "normal", "color"]
    _hx_interfaces = [tink_testrunner_Formatter]

    def __init__(self):
        pass

    def success(self,v):
        return self.color(v,"green")

    def error(self,v):
        return self.color(v,"red")

    def warning(self,v):
        return self.color(v,"yellow")

    def info(self,v):
        return self.color(v,"yellow")

    def extra(self,v):
        return self.color(v,"cyan")

    def mute(self,v):
        return self.color(v,"blue")

    def normal(self,v):
        return self.color(v,"")

    def color(self,v,c):
        return v

tink_testrunner_BasicFormatter._hx_class = tink_testrunner_BasicFormatter


class tink_testrunner_AnsiFormatter(tink_testrunner_BasicFormatter):
    _hx_class_name = "tink.testrunner.AnsiFormatter"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["color"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = tink_testrunner_BasicFormatter


    def __init__(self):
        super().__init__()

    def color(self,v,c):
        c1 = c
        _hx_local_0 = len(c1)
        if (_hx_local_0 == 4):
            if (c1 == "blue"):
                return ((HxOverrides.stringOrNull(ANSI.aset([Attribute.Blue])) + ("null" if v is None else v)) + HxOverrides.stringOrNull(ANSI.aset([Attribute.DefaultForeground])))
            elif (c1 == "cyan"):
                return ((HxOverrides.stringOrNull(ANSI.aset([Attribute.Cyan])) + ("null" if v is None else v)) + HxOverrides.stringOrNull(ANSI.aset([Attribute.DefaultForeground])))
            else:
                return (HxOverrides.stringOrNull(ANSI.aset([Attribute.DefaultForeground])) + ("null" if v is None else v))
        elif (_hx_local_0 == 5):
            if (c1 == "green"):
                return ((HxOverrides.stringOrNull(ANSI.aset([Attribute.Green])) + ("null" if v is None else v)) + HxOverrides.stringOrNull(ANSI.aset([Attribute.DefaultForeground])))
            else:
                return (HxOverrides.stringOrNull(ANSI.aset([Attribute.DefaultForeground])) + ("null" if v is None else v))
        elif (_hx_local_0 == 7):
            if (c1 == "magenta"):
                return ((HxOverrides.stringOrNull(ANSI.aset([Attribute.Magenta])) + ("null" if v is None else v)) + HxOverrides.stringOrNull(ANSI.aset([Attribute.DefaultForeground])))
            else:
                return (HxOverrides.stringOrNull(ANSI.aset([Attribute.DefaultForeground])) + ("null" if v is None else v))
        elif (_hx_local_0 == 3):
            if (c1 == "red"):
                return ((HxOverrides.stringOrNull(ANSI.aset([Attribute.Red])) + ("null" if v is None else v)) + HxOverrides.stringOrNull(ANSI.aset([Attribute.DefaultForeground])))
            else:
                return (HxOverrides.stringOrNull(ANSI.aset([Attribute.DefaultForeground])) + ("null" if v is None else v))
        elif (_hx_local_0 == 6):
            if (c1 == "yellow"):
                return ((HxOverrides.stringOrNull(ANSI.aset([Attribute.Yellow])) + ("null" if v is None else v)) + HxOverrides.stringOrNull(ANSI.aset([Attribute.DefaultForeground])))
            else:
                return (HxOverrides.stringOrNull(ANSI.aset([Attribute.DefaultForeground])) + ("null" if v is None else v))
        else:
            return (HxOverrides.stringOrNull(ANSI.aset([Attribute.DefaultForeground])) + ("null" if v is None else v))

tink_testrunner_AnsiFormatter._hx_class = tink_testrunner_AnsiFormatter


class tink_testrunner_BasicReporter:
    _hx_class_name = "tink.testrunner.BasicReporter"
    _hx_is_interface = "False"
    __slots__ = ("noise", "formatter")
    _hx_fields = ["noise", "formatter"]
    _hx_methods = ["report", "println", "indent", "formatError"]
    _hx_interfaces = [tink_testrunner_Reporter]

    def __init__(self,formatter = None):
        self.noise = tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(tink_core_Noise.Noise))
        self.formatter = (formatter if ((formatter is not None)) else (tink_testrunner_BasicFormatter() if ((Sys.systemName() == "Windows")) else tink_testrunner_AnsiFormatter()))

    def report(self,_hx_type):
        tmp = _hx_type.index
        if (tmp == 0):
            pass
        elif (tmp == 1):
            hasCasesToRun = _hx_type.params[1]
            info = _hx_type.params[0]
            if hasCasesToRun:
                self.println(" ")
                m = (HxOverrides.stringOrNull(self.formatter.info(info.name)) + ": ")
                if (Reflect.field(info,"pos") is not None):
                    m = (("null" if m is None else m) + HxOverrides.stringOrNull(self.formatter.extra((((("[" + HxOverrides.stringOrNull(Reflect.field(info,"pos").fileName)) + ":") + Std.string(Reflect.field(info,"pos").lineNumber)) + "]"))))
                self.println(m)
        elif (tmp == 2):
            shouldRun = _hx_type.params[1]
            info = _hx_type.params[0]
            if shouldRun:
                m = (HxOverrides.stringOrNull(self.formatter.info(self.indent(info.name,2))) + ": ")
                if (info.pos is not None):
                    m = (("null" if m is None else m) + HxOverrides.stringOrNull(self.formatter.extra((((("[" + HxOverrides.stringOrNull(info.pos.fileName)) + ":") + Std.string(info.pos.lineNumber)) + "] "))))
                if (info.description is not None):
                    m = (("null" if m is None else m) + HxOverrides.stringOrNull(self.formatter.mute(info.description)))
                self.println(m)
        elif (tmp == 3):
            assertion = _hx_type.params[0]
            failure = None
            holds = None
            _g = assertion.holds
            holds1 = _g.index
            if (holds1 == 0):
                _g1 = _g.params[0]
                holds = self.formatter.success("[OK]")
            elif (holds1 == 1):
                msg = _g.params[0]
                failure = msg
                holds = self.formatter.error("[FAIL]")
            else:
                pass
            pos = self.formatter.extra((((("[" + HxOverrides.stringOrNull(assertion.pos.fileName)) + ":") + Std.string(assertion.pos.lineNumber)) + "]"))
            m = self.indent(((((("- " + ("null" if holds is None else holds)) + " ") + ("null" if pos is None else pos)) + " ") + HxOverrides.stringOrNull(assertion.description)),4)
            self.println(m)
            if (failure is not None):
                self.println(self.formatter.error(self.indent(failure,8)))
        elif (tmp == 4):
            _g = _hx_type.params[0]
            _g1 = _g.info
            result = _g.result
            if (result.index == 1):
                e = result.params[0]
                self.println(self.formatter.error(self.indent(("- " + HxOverrides.stringOrNull(self.formatError(e))),4)))
        elif (tmp == 5):
            result = _hx_type.params[0]
            _g = result.result
            tmp = _g.index
            if (tmp == 0):
                _g1 = _g.params[0]
            elif (tmp == 1):
                e = _g.params[0]
                self.println(self.formatter.error(self.indent(("Setup Failed: " + HxOverrides.stringOrNull(self.formatError(e))),2)))
            elif (tmp == 2):
                _g1 = _g.params[1]
                e = _g.params[0]
                self.println(self.formatter.error(self.indent(("Teardown Failed: " + HxOverrides.stringOrNull(self.formatError(e))),2)))
            else:
                pass
        elif (tmp == 6):
            result = _hx_type.params[0]
            summary = tink_testrunner__Runner_BatchResult_Impl_.summary(result)
            total = len(summary.assertions)
            failures = 0
            errors = 0
            _g = 0
            _g1 = summary.failures
            while (_g < len(_g1)):
                f = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                if (f.index == 0):
                    _g2 = f.params[0]
                    failures = (failures + 1)
                else:
                    errors = (errors + 1)
            success = (total - failures)
            m_b = python_lib_io_StringIO()
            m_b.write(Std.string(total))
            m_b.write(" Assertion")
            if (total > 1):
                m_b.write("s")
            m_b.write("   ")
            m_b.write(Std.string(success))
            m_b.write(" Success")
            m_b.write("   ")
            m_b.write(Std.string(failures))
            m_b.write(" Failure")
            if (failures > 1):
                m_b.write("s")
            m_b.write("   ")
            m_b.write(Std.string(errors))
            m_b.write(" Error")
            if (errors > 1):
                m_b.write("s")
            m_b.write("   ")
            m = m_b.getvalue()
            self.println(" ")
            self.println((self.formatter.success(m) if (((failures == 0) and ((errors == 0)))) else self.formatter.error(m)))
            self.println(" ")
        else:
            pass
        return self.noise

    def println(self,v):
        _hx_str = Std.string(v)
        python_Lib.printString((("" + ("null" if _hx_str is None else _hx_str)) + HxOverrides.stringOrNull(python_Lib.lineEnd)))

    def indent(self,v,i = None):
        if (i is None):
            i = 0
        def _hx_local_0(line):
            return (HxOverrides.stringOrNull(StringTools.lpad(""," ",i)) + ("null" if line is None else line))
        _this = list(map(_hx_local_0,v.split("\n")))
        return "\n".join([python_Boot.toString1(x1,'') for x1 in _this])

    def formatError(self,e):
        _hx_str = e.toString()
        if (e.data is not None):
            _hx_str = (("null" if _hx_str is None else _hx_str) + (("\n" + Std.string(e.data))))
        return _hx_str

tink_testrunner_BasicReporter._hx_class = tink_testrunner_BasicReporter


class tink_testrunner_Runner:
    _hx_class_name = "tink.testrunner.Runner"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["exit", "run", "runSuite", "runCase"]

    @staticmethod
    def exit(result):
        Sys.exit(len(tink_testrunner__Runner_BatchResult_Impl_.summary(result).failures))

    @staticmethod
    def run(batch,reporter = None,timers = None):
        if (reporter is None):
            reporter = tink_testrunner_BasicReporter()
        if (timers is None):
            timers = tink_testrunner_HaxeTimerManager()
        includeMode = False
        _g = 0
        _g1 = batch
        while (_g < len(_g1)):
            s = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if includeMode:
                break
            _g2 = 0
            _g3 = s.cases
            while (_g2 < len(_g3)):
                c = (_g3[_g2] if _g2 >= 0 and _g2 < len(_g3) else None)
                _g2 = (_g2 + 1)
                if c.include:
                    includeMode = True
                    break
        def _hx_local_8():
            def _hx_local_7(cb):
                def _hx_local_6(_):
                    iter_current = None
                    iter_array = None
                    iter_current = 0
                    iter_array = batch
                    results = []
                    next = None
                    def _hx_local_5():
                        nonlocal iter_current
                        if (iter_current < len(iter_array)):
                            iter_current = (iter_current + 1)
                            suite = python_internal_ArrayImpl._get(iter_array, (iter_current - 1))
                            def _hx_local_3(o):
                                results.append(o)
                                reporter.report(tink_testrunner_ReportType.SuiteFinish(o)).handle(tink_core__Callback_Callback_Impl_.fromNiladic(next))
                            tink_testrunner_Runner.runSuite(suite,reporter,timers,includeMode).handle(_hx_local_3)
                        else:
                            next1 = reporter.report(tink_testrunner_ReportType.BatchFinish(results))
                            _g = cb
                            a1 = results
                            def _hx_local_4():
                                _g(a1)
                            next1.handle(tink_core__Callback_Callback_Impl_.fromNiladic(_hx_local_4))
                    next = _hx_local_5
                    next()
                reporter.report(tink_testrunner_ReportType.BatchStart).handle(_hx_local_6)
            return tink_core__Future_Future_Impl_.make(_hx_local_7)
        return _hx_local_8()

    @staticmethod
    def runSuite(suite,reporter,timers,includeMode):
        def _hx_local_9():
            def _hx_local_8(cb):
                cases = tink_testrunner__Suite_Suite_Impl_.getCasesToBeRun(suite,includeMode)
                hasCases = (len(cases) > 0)
                def _hx_local_7(_):
                    def _hx_local_0():
                        if hasCases:
                            return suite.setup()
                        else:
                            return tink_core__Promise_Promise_Impl_.NOISE
                    setup = _hx_local_0
                    def _hx_local_1():
                        if hasCases:
                            return suite.teardown()
                        else:
                            return tink_core__Promise_Promise_Impl_.NOISE
                    teardown = _hx_local_1
                    iter_current = None
                    iter_array = None
                    iter_current = 0
                    iter_array = suite.cases
                    results = []
                    next = None
                    def _hx_local_5():
                        nonlocal iter_current
                        if (iter_current < len(iter_array)):
                            iter_current = (iter_current + 1)
                            caze = python_internal_ArrayImpl._get(iter_array, (iter_current - 1))
                            def _hx_local_3(r):
                                results.append(r)
                                next()
                            tink_testrunner_Runner.runCase(caze,suite,reporter,timers,tink_testrunner__Case_Case_Impl_.shouldRun(caze,includeMode)).handle(_hx_local_3)
                        else:
                            def _hx_local_4(o):
                                next = None
                                next1 = o.index
                                if (next1 == 0):
                                    _g = o.params[0]
                                    next = tink_testrunner_SuiteResultType.Success(results)
                                elif (next1 == 1):
                                    e = o.params[0]
                                    next = tink_testrunner_SuiteResultType.TeardownFailed(e,results)
                                else:
                                    pass
                                cb(_hx_AnonObject({'info': suite.info, 'result': next}))
                            teardown().handle(_hx_local_4)
                    next = _hx_local_5
                    def _hx_local_6(o):
                        tmp = o.index
                        if (tmp == 0):
                            _g = o.params[0]
                            next()
                        elif (tmp == 1):
                            e = o.params[0]
                            cb(_hx_AnonObject({'info': suite.info, 'result': tink_testrunner_SuiteResultType.SetupFailed(e)}))
                        else:
                            pass
                    setup().handle(_hx_local_6)
                reporter.report(tink_testrunner_ReportType.SuiteStart(suite.info,hasCases)).handle(_hx_local_7)
            return tink_core__Future_Future_Impl_.make(_hx_local_8)
        return _hx_local_9()

    @staticmethod
    def runCase(caze,suite,reporter,timers,shouldRun):
        def _hx_local_14():
            def _hx_local_13(cb):
                if shouldRun:
                    def _hx_local_10(_):
                        def _hx_local_6(_):
                            assertions = []
                            def _hx_local_5():
                                def _hx_local_3(a):
                                    assertions.append(a)
                                    def _hx_local_2(_):
                                        return tink_streams_Handled.Resume
                                    ret = reporter.report(tink_testrunner_ReportType.Assertion(a)).map(_hx_local_2)
                                    return ret.gather()
                                def _hx_local_4(o):
                                    this1 = o.index
                                    if (this1 == 0):
                                        _g = o.params[0]
                                        raise haxe_Exception.thrown("unreachable")
                                    elif (this1 == 2):
                                        e = o.params[0]
                                        return tink_core_Outcome.Failure(e)
                                    elif (this1 == 3):
                                        return tink_core_Outcome.Success(assertions)
                                    else:
                                        pass
                                return tink_testrunner_TimeoutHelper.timeout(tink_core__Future_Future_Impl_.next(caze.execute().forEach(tink_streams__Stream_Handler_Impl_.ofSafe(_hx_local_3)),tink_core__Promise_Next_Impl_.ofSafe(_hx_local_4)),caze.timeout,timers,_hx_AnonObject({'fileName': "tink/testrunner/Runner.hx", 'lineNumber': 107, 'className': "tink.testrunner.Runner", 'methodName': "runCase"}))
                            return _hx_local_5()
                        def _hx_local_9(result):
                            def _hx_local_8():
                                def _hx_local_7(_):
                                    return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(tink_core_Outcome.Success(result)))
                                return tink_core__Promise_Promise_Impl_.next(tink_testrunner_TimeoutHelper.timeout(suite.after(),caze.timeout,timers,caze.pos),_hx_local_7)
                            return _hx_local_8()
                        def _hx_local_1(result):
                            results = None
                            results1 = result.index
                            if (results1 == 0):
                                v = result.params[0]
                                results = tink_testrunner_CaseResultType.Succeeded(v)
                            elif (results1 == 1):
                                e = result.params[0]
                                results = tink_testrunner_CaseResultType.Failed(e)
                            else:
                                pass
                            results1 = _hx_AnonObject({'info': caze.info, 'result': results})
                            def _hx_local_0(_):
                                cb(results1)
                            reporter.report(tink_testrunner_ReportType.CaseFinish(results1)).handle(_hx_local_0)
                        tink_core__Promise_Promise_Impl_.next(tink_core__Promise_Promise_Impl_.next(tink_testrunner_TimeoutHelper.timeout(suite.before(),caze.timeout,timers,caze.pos),_hx_local_6),_hx_local_9).handle(_hx_local_1)
                    reporter.report(tink_testrunner_ReportType.CaseStart(caze.info,shouldRun)).handle(_hx_local_10)
                else:
                    def _hx_local_12(_):
                        results = _hx_AnonObject({'info': caze.info, 'result': tink_testrunner_CaseResultType.Excluded})
                        def _hx_local_11(_):
                            cb(results)
                        reporter.report(tink_testrunner_ReportType.CaseFinish(results)).handle(_hx_local_11)
                    reporter.report(tink_testrunner_ReportType.CaseStart(caze.info,shouldRun)).handle(_hx_local_12)
            return tink_core__Future_Future_Impl_.make(_hx_local_13)
        return _hx_local_14()
tink_testrunner_Runner._hx_class = tink_testrunner_Runner


class tink_testrunner_TimeoutHelper:
    _hx_class_name = "tink.testrunner.TimeoutHelper"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["timeout"]

    @staticmethod
    def timeout(promise,ms,timers,pos = None):
        def _hx_local_3():
            def _hx_local_2(cb):
                done = False
                timer = None
                def _hx_local_0(o):
                    nonlocal done
                    done = True
                    if (timer is not None):
                        timer.stop()
                    cb(o)
                link = promise.handle(_hx_local_0)
                if ((not done) and ((timers is not None))):
                    def _hx_local_1():
                        if (link is not None):
                            link.cancel()
                        cb(tink_core_Outcome.Failure(tink_core_TypedError(None,(("Timed out after " + Std.string(ms)) + " ms"),pos)))
                    timer = timers.schedule(ms,_hx_local_1)
            return tink_core__Future_Future_Impl_.make(_hx_local_2)
        return _hx_local_3()
tink_testrunner_TimeoutHelper._hx_class = tink_testrunner_TimeoutHelper


class tink_testrunner__Runner_BatchResult_Impl_:
    _hx_class_name = "tink.testrunner._Runner.BatchResult_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["summary"]

    @staticmethod
    def summary(this1):
        ret = _hx_AnonObject({'assertions': [], 'failures': []})
        def _hx_local_3(cases):
            _g = 0
            while (_g < len(cases)):
                c = (cases[_g] if _g >= 0 and _g < len(cases) else None)
                _g = (_g + 1)
                _g1 = c.result
                handleCases = _g1.index
                if (handleCases == 0):
                    assertions = _g1.params[0]
                    handleCases1 = (ret.assertions + assertions)
                    ret.assertions = handleCases1
                    def _hx_local_1(a):
                        return tink_testrunner_FailureType.AssertionFailed(a)
                    def _hx_local_2(a):
                        return (not tink_core_OutcomeTools.isSuccess(a.holds))
                    handleCases2 = (ret.failures + list(map(_hx_local_1,list(filter(_hx_local_2,assertions)))))
                    ret.failures = handleCases2
                elif (handleCases == 1):
                    e = _g1.params[0]
                    _this = ret.failures
                    _this.append(tink_testrunner_FailureType.CaseFailed(e))
                elif (handleCases == 2):
                    pass
                else:
                    pass
        handleCases = _hx_local_3
        _g = 0
        while (_g < len(this1)):
            s = (this1[_g] if _g >= 0 and _g < len(this1) else None)
            _g = (_g + 1)
            _g1 = s.result
            tmp = _g1.index
            if (tmp == 0):
                cases = _g1.params[0]
                handleCases(cases)
            elif (tmp == 1):
                e = _g1.params[0]
                _this = ret.failures
                _this.append(tink_testrunner_FailureType.SuiteFailed(e))
            elif (tmp == 2):
                cases1 = _g1.params[1]
                e1 = _g1.params[0]
                handleCases(cases1)
                _this1 = ret.failures
                _this1.append(tink_testrunner_FailureType.SuiteFailed(e1))
            else:
                pass
        return ret
tink_testrunner__Runner_BatchResult_Impl_._hx_class = tink_testrunner__Runner_BatchResult_Impl_

class tink_testrunner_SuiteResultType(Enum):
    __slots__ = ()
    _hx_class_name = "tink.testrunner.SuiteResultType"
    _hx_constructs = ["Success", "SetupFailed", "TeardownFailed"]

    @staticmethod
    def Success(cases):
        return tink_testrunner_SuiteResultType("Success", 0, (cases,))

    @staticmethod
    def SetupFailed(e):
        return tink_testrunner_SuiteResultType("SetupFailed", 1, (e,))

    @staticmethod
    def TeardownFailed(e,cases):
        return tink_testrunner_SuiteResultType("TeardownFailed", 2, (e,cases))
tink_testrunner_SuiteResultType._hx_class = tink_testrunner_SuiteResultType

class tink_testrunner_CaseResultType(Enum):
    __slots__ = ()
    _hx_class_name = "tink.testrunner.CaseResultType"
    _hx_constructs = ["Succeeded", "Failed", "Excluded"]

    @staticmethod
    def Succeeded(assertions):
        return tink_testrunner_CaseResultType("Succeeded", 0, (assertions,))

    @staticmethod
    def Failed(e):
        return tink_testrunner_CaseResultType("Failed", 1, (e,))
tink_testrunner_CaseResultType.Excluded = tink_testrunner_CaseResultType("Excluded", 2, ())
tink_testrunner_CaseResultType._hx_class = tink_testrunner_CaseResultType

class tink_testrunner_FailureType(Enum):
    __slots__ = ()
    _hx_class_name = "tink.testrunner.FailureType"
    _hx_constructs = ["AssertionFailed", "CaseFailed", "SuiteFailed"]

    @staticmethod
    def AssertionFailed(assertion):
        return tink_testrunner_FailureType("AssertionFailed", 0, (assertion,))

    @staticmethod
    def CaseFailed(err):
        return tink_testrunner_FailureType("CaseFailed", 1, (err,))

    @staticmethod
    def SuiteFailed(err):
        return tink_testrunner_FailureType("SuiteFailed", 2, (err,))
tink_testrunner_FailureType._hx_class = tink_testrunner_FailureType


class tink_testrunner__Suite_Suite_Impl_:
    _hx_class_name = "tink.testrunner._Suite.Suite_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["ofCases", "ofCase", "getCasesToBeRun"]

    @staticmethod
    def ofCases(cases,pos = None):
        _g = []
        _g1 = 0
        while (_g1 < len(cases)):
            c = (cases[_g1] if _g1 >= 0 and _g1 < len(cases) else None)
            _g1 = (_g1 + 1)
            x = None
            _g2 = Type.getClass(c)
            if (_g2 is None):
                x = None
            else:
                c1 = _g2
                x = Type.getClassName(c1)
            _g.append(x)
        return tink_testrunner_BasicSuite(_hx_AnonObject({'name': ", ".join([python_Boot.toString1(x1,'') for x1 in _g]), 'pos': pos}),cases,_hx_AnonObject({'fileName': "tink/testrunner/Suite.hx", 'lineNumber': 36, 'className': "tink.testrunner._Suite.Suite_Impl_", 'methodName': "ofCases"}))

    @staticmethod
    def ofCase(caze,pos = None):
        cases = [caze]
        _g = []
        _g1 = 0
        while (_g1 < len(cases)):
            c = (cases[_g1] if _g1 >= 0 and _g1 < len(cases) else None)
            _g1 = (_g1 + 1)
            x = None
            _g2 = Type.getClass(c)
            if (_g2 is None):
                x = None
            else:
                c1 = _g2
                x = Type.getClassName(c1)
            _g.append(x)
        return tink_testrunner_BasicSuite(_hx_AnonObject({'name': ", ".join([python_Boot.toString1(x1,'') for x1 in _g]), 'pos': pos}),cases,_hx_AnonObject({'fileName': "tink/testrunner/Suite.hx", 'lineNumber': 36, 'className': "tink.testrunner._Suite.Suite_Impl_", 'methodName': "ofCases"}))

    @staticmethod
    def getCasesToBeRun(this1,includeMode):
        def _hx_local_1():
            def _hx_local_0(c):
                return tink_testrunner__Case_Case_Impl_.shouldRun(c,includeMode)
            return list(filter(_hx_local_0,this1.cases))
        return _hx_local_1()
tink_testrunner__Suite_Suite_Impl_._hx_class = tink_testrunner__Suite_Suite_Impl_


class tink_testrunner_SuiteObject:
    _hx_class_name = "tink.testrunner.SuiteObject"
    _hx_is_interface = "True"
    __slots__ = ("info", "cases")
    _hx_fields = ["info", "cases"]
    _hx_methods = ["setup", "before", "after", "teardown"]
tink_testrunner_SuiteObject._hx_class = tink_testrunner_SuiteObject


class tink_testrunner_BasicSuite:
    _hx_class_name = "tink.testrunner.BasicSuite"
    _hx_is_interface = "False"
    __slots__ = ("info", "cases")
    _hx_fields = ["info", "cases"]
    _hx_methods = ["setup", "before", "after", "teardown"]
    _hx_interfaces = [tink_testrunner_SuiteObject]

    def __init__(self,info,cases,pos = None):
        self.info = info
        self.cases = cases
        if (Reflect.field(info,"pos") is None):
            Reflect.setField(info,"pos",pos)
        _g = 0
        while (_g < len(cases)):
            c = (cases[_g] if _g >= 0 and _g < len(cases) else None)
            _g = (_g + 1)
            c.suite = self

    def setup(self):
        return tink_core__Promise_Promise_Impl_.NOISE

    def before(self):
        return tink_core__Promise_Promise_Impl_.NOISE

    def after(self):
        return tink_core__Promise_Promise_Impl_.NOISE

    def teardown(self):
        return tink_core__Promise_Promise_Impl_.NOISE

tink_testrunner_BasicSuite._hx_class = tink_testrunner_BasicSuite


class tink_testrunner_Timer:
    _hx_class_name = "tink.testrunner.Timer"
    _hx_is_interface = "True"
    __slots__ = ()
    _hx_methods = ["stop"]
tink_testrunner_Timer._hx_class = tink_testrunner_Timer


class tink_testrunner_TimerManager:
    _hx_class_name = "tink.testrunner.TimerManager"
    _hx_is_interface = "True"
    __slots__ = ()
    _hx_methods = ["schedule"]
tink_testrunner_TimerManager._hx_class = tink_testrunner_TimerManager


class tink_testrunner_HaxeTimer:
    _hx_class_name = "tink.testrunner.HaxeTimer"
    _hx_is_interface = "False"
    __slots__ = ("timer",)
    _hx_fields = ["timer"]
    _hx_methods = ["stop"]
    _hx_interfaces = [tink_testrunner_Timer]

    def __init__(self,ms,f):
        self.timer = haxe_Timer.delay(f,ms)

    def stop(self):
        if (self.timer is not None):
            self.timer.stop()
            self.timer = None

tink_testrunner_HaxeTimer._hx_class = tink_testrunner_HaxeTimer


class tink_testrunner_HaxeTimerManager:
    _hx_class_name = "tink.testrunner.HaxeTimerManager"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_methods = ["schedule"]
    _hx_interfaces = [tink_testrunner_TimerManager]

    def __init__(self):
        pass

    def schedule(self,ms,f):
        return tink_testrunner_HaxeTimer(ms,f)

tink_testrunner_HaxeTimerManager._hx_class = tink_testrunner_HaxeTimerManager


class tink_unit_Assert:
    _hx_class_name = "tink.unit.Assert"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["printer", "fail"]

    @staticmethod
    def fail(e,pos = None):
        return tink_streams__Stream_Stream_Impl_.ofError(e)
tink_unit_Assert._hx_class = tink_unit_Assert


class tink_unit__AssertionBuffer_Impl(tink_streams_SignalStream):
    _hx_class_name = "tink.unit._AssertionBuffer.Impl"
    _hx_is_interface = "False"
    __slots__ = ("trigger",)
    _hx_fields = ["trigger"]
    _hx_methods = ["yield"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = tink_streams_SignalStream


    def __init__(self):
        self.trigger = None
        trigger = tink_core__Signal_Signal_Impl_.trigger()
        super().__init__(trigger)
        self.trigger = trigger

    def _hx_yield(self,data):
        self.trigger.handlers.invoke(data)

tink_unit__AssertionBuffer_Impl._hx_class = tink_unit__AssertionBuffer_Impl


class tink_unit__AssertionBuffer_AssertionBuffer_Impl_:
    _hx_class_name = "tink.unit._AssertionBuffer.AssertionBuffer_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["_new", "emit", "fail", "defer", "done", "handle"]

    @staticmethod
    def _new():
        this1 = tink_unit__AssertionBuffer_Impl()
        return this1

    @staticmethod
    def emit(this1,assertion):
        this1.trigger.handlers.invoke(tink_streams_Yield.Data(assertion))

    @staticmethod
    def fail(this1,code = None,reason = None,pos = None):
        if (code is None):
            code = reason.code
        data = tink_streams_Yield.Fail(tink_core_TypedError(code,reason.message,pos))
        this1.trigger.handlers.invoke(data)
        return this1

    @staticmethod
    def defer(this1,f):
        tink_core__Callback_Callback_Impl_.defer(f)
        return this1

    @staticmethod
    def done(this1):
        this1.trigger.handlers.invoke(tink_streams_Yield.End)
        return this1

    @staticmethod
    def handle(this1,outcome):
        tmp = outcome.index
        if (tmp == 0):
            _g = outcome.params[0]
            this1.trigger.handlers.invoke(tink_streams_Yield.End)
        elif (tmp == 1):
            e = outcome.params[0]
            code = e.code
            if (code is None):
                code = e.code
            data = tink_streams_Yield.Fail(tink_core_TypedError(code,e.message,_hx_AnonObject({'fileName': "tink/unit/AssertionBuffer.hx", 'lineNumber': 80, 'className': "tink.unit._AssertionBuffer.AssertionBuffer_Impl_", 'methodName': "handle"})))
            this1.trigger.handlers.invoke(data)
        else:
            pass
tink_unit__AssertionBuffer_AssertionBuffer_Impl_._hx_class = tink_unit__AssertionBuffer_AssertionBuffer_Impl_


class tink_unit__AssertionBuffer_FailingReason_Impl_:
    _hx_class_name = "tink.unit._AssertionBuffer.FailingReason_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["ofString"]

    @staticmethod
    def ofString(e):
        return tink_core_TypedError(None,e,_hx_AnonObject({'fileName': "tink/unit/AssertionBuffer.hx", 'lineNumber': 89, 'className': "tink.unit._AssertionBuffer.FailingReason_Impl_", 'methodName': "ofString"}))
tink_unit__AssertionBuffer_FailingReason_Impl_._hx_class = tink_unit__AssertionBuffer_FailingReason_Impl_


class tink_unit_TestBatch:
    _hx_class_name = "tink.unit.TestBatch"
    _hx_is_interface = "False"
    __slots__ = ()
tink_unit_TestBatch._hx_class = tink_unit_TestBatch


class tink_unit_TestCase:
    _hx_class_name = "tink.unit.TestCase"
    _hx_is_interface = "False"
    __slots__ = ("suite", "info", "timeout", "include", "exclude", "pos", "test")
    _hx_fields = ["suite", "info", "timeout", "include", "exclude", "pos", "test"]
    _hx_methods = ["execute"]
    _hx_interfaces = [tink_testrunner_CaseObject]

    def __init__(self,info,test,timeout,include,exclude,pos = None):
        self.suite = None
        self.info = info
        self.test = test
        self.timeout = timeout
        self.include = include
        self.exclude = exclude
        self.pos = pos

    def execute(self):
        return self.test()

tink_unit_TestCase._hx_class = tink_unit_TestCase


class tink_unit_TestSuiteBuilder:
    _hx_class_name = "tink.unit.TestSuiteBuilder"
    _hx_is_interface = "False"
    __slots__ = ()
tink_unit_TestSuiteBuilder._hx_class = tink_unit_TestSuiteBuilder


class tink_unit_TestSuiteBase(tink_testrunner_BasicSuite):
    _hx_class_name = "tink.unit.TestSuiteBase"
    _hx_is_interface = "False"
    __slots__ = ("target",)
    _hx_fields = ["target"]
    _hx_methods = []
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = tink_testrunner_BasicSuite


    def __init__(self,info,cases,pos = None):
        self.target = None
        super().__init__(info,cases,pos)

tink_unit_TestSuiteBase._hx_class = tink_unit_TestSuiteBase


class tink_unit_TestSuite:
    _hx_class_name = "tink.unit.TestSuite"
    _hx_is_interface = "False"
    __slots__ = ()
tink_unit_TestSuite._hx_class = tink_unit_TestSuite


class tink_unit_TestSuiteBuilder0(tink_unit_TestSuiteBase):
    _hx_class_name = "tink.unit.TestSuiteBuilder0"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = []
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = tink_unit_TestSuiteBase


    def __init__(self,target,name = None):
        pos = _hx_AnonObject({'lineNumber': 22, 'fileName': "tests/RunTests.hx", 'methodName': "quick_test", 'className': "Test"})
        def _hx_local_0():
            target1 = target
            this1 = tink_unit__AssertionBuffer_Impl()
            return tink_streams__Stream_Stream_Impl_.ofIterator(haxe_iterators_ArrayIterator([target1.quick_test(this1)]))
        tmp = tink_unit_TestCase(_hx_AnonObject({'name': "quick_test", 'description': None, 'pos': _hx_AnonObject({'lineNumber': 22, 'fileName': "tests/RunTests.hx", 'methodName': "quick_test", 'className': "Test"})}),_hx_local_0,5000,False,False,pos)
        super().__init__(_hx_AnonObject({'name': ("Test" if ((name is None)) else name), 'pos': _hx_AnonObject({'lineNumber': 19, 'fileName': "tests/RunTests.hx", 'methodName': None, 'className': "Test"})}),[tmp],_hx_AnonObject({'fileName': "tink/unit/TestBuilder.hx", 'lineNumber': 130, 'className': "tink.unit.TestSuiteBuilder0", 'methodName': "new"}))
        self.target = target
tink_unit_TestSuiteBuilder0._hx_class = tink_unit_TestSuiteBuilder0

Math.NEGATIVE_INFINITY = float("-inf")
Math.POSITIVE_INFINITY = float("inf")
Math.NaN = float("nan")
Math.PI = python_lib_Math.pi

def _hx_init_Sys_environ():
    def _hx_local_0():
        Sys.environ = haxe_ds_StringMap()
        env = python_lib_Os.environ
        key = python_HaxeIterator(iter(env.keys()))
        while key.hasNext():
            key1 = key.next()
            _this = Sys.environ
            value = env.get(key1,None)
            _this.h[key1] = value
        return Sys.environ
    return _hx_local_0()
Sys.environ = _hx_init_Sys_environ()
python_Boot.keywords = set(["and", "del", "from", "not", "with", "as", "elif", "global", "or", "yield", "assert", "else", "if", "pass", "None", "break", "except", "import", "raise", "True", "class", "exec", "in", "return", "False", "continue", "finally", "is", "try", "def", "for", "lambda", "while"])
python_Boot.prefixLength = len("_hx_")
ANSI.ESCAPE = "\x1B"
ANSI.BELL = "\x07"
ANSI.CSI = ("\x1B" + "[")
ANSI.attr = Attribute
def _hx_init_ANSI_values():
    def _hx_local_0():
        _g = haxe_ds_EnumValueMap()
        _g.set(Attribute.Off,0)
        _g.set(Attribute.Bold,1)
        _g.set(Attribute.Underline,4)
        _g.set(Attribute.Blink,5)
        _g.set(Attribute.ReverseVideo,7)
        _g.set(Attribute.Concealed,8)
        _g.set(Attribute.BoldOff,22)
        _g.set(Attribute.UnderlineOff,24)
        _g.set(Attribute.BlinkOff,25)
        _g.set(Attribute.NormalVideo,27)
        _g.set(Attribute.ConcealedOff,28)
        _g.set(Attribute.Black,30)
        _g.set(Attribute.Red,31)
        _g.set(Attribute.Green,32)
        _g.set(Attribute.Yellow,33)
        _g.set(Attribute.Blue,34)
        _g.set(Attribute.Magenta,35)
        _g.set(Attribute.Cyan,36)
        _g.set(Attribute.White,37)
        _g.set(Attribute.DefaultForeground,39)
        _g.set(Attribute.BlackBack,40)
        _g.set(Attribute.RedBack,41)
        _g.set(Attribute.GreenBack,42)
        _g.set(Attribute.YellowBack,43)
        _g.set(Attribute.BlueBack,44)
        _g.set(Attribute.MagentaBack,45)
        _g.set(Attribute.CyanBack,46)
        _g.set(Attribute.WhiteBack,47)
        _g.set(Attribute.DefaultBackground,49)
        return _g
    return _hx_local_0()
ANSI.values = _hx_init_ANSI_values()
ANSI.set = Reflect.makeVarArgs(ANSI.aset)
ANSI.available = ANSI.detectSupport()
ANSI.strip = False
ANSI.stripIfUnavailable = True
def _hx_init_ANSI_sequences():
    def _hx_local_0():
        _g = haxe_ds_StringMap()
        _g.h["eraseDisplayToEnd"] = _hx_AnonObject({'val': (("\x1B" + "[") + "J"), 'doc': "Erase from cursor to the end of display."})
        _g.h["eraseDisplayToCursor"] = _hx_AnonObject({'val': (("\x1B" + "[") + "1J"), 'doc': "Erase from the start of diplay to cursor (inclusive)."})
        _g.h["eraseDisplay"] = _hx_AnonObject({'val': (("\x1B" + "[") + "2J"), 'doc': "Erase display and move cursor to the top-left."})
        _g.h["eraseLineToEnd"] = _hx_AnonObject({'val': (("\x1B" + "[") + "K"), 'doc': "Erase from cursor to the end of line."})
        _g.h["eraseLineToCursor"] = _hx_AnonObject({'val': (("\x1B" + "[") + "1K"), 'doc': "Erase from the start of line to cursor (inclusive)."})
        _g.h["eraseLine"] = _hx_AnonObject({'val': (("\x1B" + "[") + "2K"), 'doc': "Erase line."})
        _g.h["eraseChar"] = _hx_AnonObject({'val': (("\x1B" + "[") + "X"), 'doc': "Erase one character."})
        _g.h["eraseChars"] = _hx_AnonObject({'val': (("\x1B" + "[") + "#X"), 'doc': "Erase # characters."})
        _g.h["insertLine"] = _hx_AnonObject({'val': (("\x1B" + "[") + "L"), 'doc': "Insert one blank line."})
        _g.h["insertLines"] = _hx_AnonObject({'val': (("\x1B" + "[") + "#L"), 'doc': "Insert # blank lines."})
        _g.h["deleteLine"] = _hx_AnonObject({'val': (("\x1B" + "[") + "M"), 'doc': "Delete one line."})
        _g.h["deleteLines"] = _hx_AnonObject({'val': (("\x1B" + "[") + "#M"), 'doc': "Delete # lines."})
        _g.h["deleteChar"] = _hx_AnonObject({'val': (("\x1B" + "[") + "P"), 'doc': "Delete one character."})
        _g.h["deleteChars"] = _hx_AnonObject({'val': (("\x1B" + "[") + "#P"), 'doc': "Delete # characters."})
        _g.h["insertChar"] = _hx_AnonObject({'val': (("\x1B" + "[") + "@"), 'doc': "Insert one blank character."})
        _g.h["insertChars"] = _hx_AnonObject({'val': (("\x1B" + "[") + "#@"), 'doc': "Insert # blank characters."})
        _g.h["moveUp"] = _hx_AnonObject({'val': (("\x1B" + "[") + "#A"), 'doc': "Move cursor up # lines."})
        _g.h["moveDown"] = _hx_AnonObject({'val': (("\x1B" + "[") + "#B"), 'doc': "Move cursor down # lines."})
        _g.h["moveRight"] = _hx_AnonObject({'val': (("\x1B" + "[") + "#C"), 'doc': "Move cursor right # characters."})
        _g.h["moveLeft"] = _hx_AnonObject({'val': (("\x1B" + "[") + "#D"), 'doc': "Move cursor left # characters."})
        _g.h["moveDownReset"] = _hx_AnonObject({'val': (("\x1B" + "[") + "#E"), 'doc': "Move cursor down # lines and to first column."})
        _g.h["moveUpReset"] = _hx_AnonObject({'val': (("\x1B" + "[") + "#F"), 'doc': "Move cursor up # lines and to first column."})
        _g.h["setX"] = _hx_AnonObject({'val': (("\x1B" + "[") + "#G"), 'doc': "Move cursor to column #."})
        _g.h["setY"] = _hx_AnonObject({'val': (("\x1B" + "[") + "#d"), 'doc': "Move cursor to line #."})
        _g.h["reset"] = _hx_AnonObject({'val': (("\x1B" + "[") + "H"), 'doc': "Move cursor to top-left."})
        _g.h["resetY"] = _hx_AnonObject({'val': (("\x1B" + "[") + "#H"), 'doc': "Move cursor to line # and first column."})
        _g.h["setXY"] = _hx_AnonObject({'val': (("\x1B" + "[") + "#;#H"), 'doc': "Move cursor to line #, column #.", 'params': [_hx_AnonObject({'index': 1, 'name': "column"}), _hx_AnonObject({'index': 0, 'name': "line"})]})
        _g.h["saveCursor"] = _hx_AnonObject({'val': (("\x1B" + "[") + "s"), 'doc': "Save cursor position."})
        _g.h["loadCursor"] = _hx_AnonObject({'val': (("\x1B" + "[") + "u"), 'doc': "Move cursor to saved position."})
        _g.h["showCursor"] = _hx_AnonObject({'val': (("\x1B" + "[") + "?25h"), 'doc': "Show cursor."})
        _g.h["hideCursor"] = _hx_AnonObject({'val': (("\x1B" + "[") + "?25l"), 'doc': "Hide cursor."})
        return _g
    return _hx_local_0()
ANSI.sequences = _hx_init_ANSI_sequences()
haxe_EntryPoint.pending = list()
haxe_EntryPoint.threadCount = 0
python_Lib.lineEnd = ("\r\n" if ((Sys.systemName() == "Windows")) else "\n")
tink_core__Callback_Callback_Impl_.depth = 0
tink_core__Callback_Callback_Impl_.MAX_DEPTH = 200
tink_core__Future_NeverFuture.inst = tink_core__Future_NeverFuture()
tink_core__Future_Future_Impl_.NULL = tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(None))
tink_core__Future_Future_Impl_.NOISE = tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(tink_core_Noise.Noise))
tink_core__Future_Future_Impl_.NEVER = tink_core__Future_NeverFuture.inst
tink_core__Lazy_Lazy_Impl_.NULL = tink_core__Lazy_LazyConst(None)
def _hx_init_tink_core__Progress_Progress_Impl__INIT():
    def _hx_local_0():
        this1 = tink_core_MPair(0.0,haxe_ds_Option._hx_None)
        return this1
    return _hx_local_0()
tink_core__Progress_Progress_Impl_.INIT = _hx_init_tink_core__Progress_Progress_Impl__INIT()
tink_core__Promise_Promise_Impl_.NULL = tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(tink_core_Outcome.Success(None)))
tink_core__Promise_Promise_Impl_.NOISE = tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(tink_core_Outcome.Success(tink_core_Noise.Noise)))
def _hx_init_tink_core__Promise_Promise_Impl__NEVER():
    def _hx_local_0():
        ret = tink_core__Future_Future_Impl_.NEVER.map(tink_core_Outcome.Success)
        return ret.gather()
    return _hx_local_0()
tink_core__Promise_Promise_Impl_.NEVER = _hx_init_tink_core__Promise_Promise_Impl__NEVER()
tink_streams_Empty.inst = tink_streams_Empty()
tink_unit_Assert.printer = haxe_macro_Printer()

RunTests.main()
haxe_EntryPoint.run()
